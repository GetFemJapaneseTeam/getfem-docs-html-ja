<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>任意の項を計算する - 高水準の汎用的な構築手順 - 弱形式言語 &mdash; GetFEM++</title>
    
    <link rel="stylesheet" href="../_static/getfem.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="GetFEM++" href="../index.html" />
    <link rel="up" title="ユーザドキュメント" href="index.html" />
    <link rel="next" title="任意の項を計算する - 低水準の汎用的な構築手順" href="gasm_low.html" />
    <link rel="prev" title="メッシュの改善" href="rmesh.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/icon.png" />
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="gasm_low.html" title="任意の項を計算する - 低水準の汎用的な構築手順"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="rmesh.html" title="メッシュの改善"
             accesskey="P">前へ</a> |</li>
        <li><a href="https://savannah.nongnu.org/projects/getfem" <img src="../_static/icon.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li></a>
        <li><a href="../index.html">GetFEM++</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">ユーザドキュメント</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="compute-arbitrary-terms-high-level-generic-assembly-procedures-weak-form-language">
<span id="ud-gasm-high"></span><span id="index-0"></span><h1>任意の項を計算する - 高水準の汎用的な構築手順 - 弱形式言語<a class="headerlink" href="#compute-arbitrary-terms-high-level-generic-assembly-procedures-weak-form-language" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>このセクションでは、現在の <em>GetFEM++</em> の主要な汎用構築を紹介します。これは、弱微分方程式の境界値問題の弱定式化を記述するために、弱形式言語に基づいているという意味で、高水準の汎用構築とされています。これは主に、非線形項を記述することが非常に難しい従来の低水準汎用構築（ <a class="reference internal" href="gasm_low.html#ud-gasm-low"><em>任意の項を計算する - 低水準の汎用的な構築手順</em></a> 参照）の問題を回避するために開発されました。逆に、このバージョンでは記号的な微分アルゴリズムが使用されています。これは、非線形結合問題の近似を多く簡略化します。弱形式のみを記述する必要があるため、接線系は自動的に計算されるためです。さらに、弱形式言語は、最適な計算コストを得るために各積分点の評価の前に最適化された命令にコンパイルされます。</p>
<p>C++で高水準の汎用構築手順を使用するためにインクルードするヘッダーファイルは、 <tt class="file docutils literal"><span class="pre">getfem/generic_assembly.h</span></tt> です。</p>
<div class="section" id="differences-in-execution-time-between-high-and-low-level-generic-assembly">
<h2>高水準と低水準の汎用構築間の実行時間の差<a class="headerlink" href="#differences-in-execution-time-between-high-and-low-level-generic-assembly" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的な線形構築の項については、高水準の汎用構築は、低水準の構築よりも高速になります。これは、高水準汎用構築が基本的な最適化された命令にコンパイルを組み込み、単純化を実行するためです。複数の単語を使う場合は、繰り返される項を単純化することにより高速になることがあります。一方、低水準汎用構築が、参照要素に線形変換を伴う要素の線形項を事前計算するメカニズムを組み込んでいるため、いくつかの単純な線形項でより速くなります。もちろん、高水準汎用構築における線形変換のための線形項を基準要素にあらかじめ計算する能力を組み込むこも可能です。しかし、言語の汎用性が高いために複雑になると思われます。結果として、高水準汎用構築では完全積分が許可されないことになります。</p>
</div>
<div class="section" id="overview-of-the-weak-form-language-syntax">
<h2>弱形式言語構文の概要<a class="headerlink" href="#overview-of-the-weak-form-language-syntax" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>境界値問題の弱定式化を記述するために、特定の弱形式言語が開発されています。これは、標準的な弱定式化の構造に近いことを意図しており、以下の成分を含みます。</p>
<blockquote>
<div><ul class="simple">
<li><p class="first">変数名: 変数のリストを与える必要があります。変数は有限要素法で記述されるか、未知変数の単純なベクトルになります。例えば、 <tt class="docutils literal"><span class="pre">u</span></tt> 、 <tt class="docutils literal"><span class="pre">v</span></tt> 、 <tt class="docutils literal"><span class="pre">p</span></tt> 、 <tt class="docutils literal"><span class="pre">pressure</span></tt> 、 <tt class="docutils literal"><span class="pre">electric_field</span></tt> は有効な変数名です。</p>
</li>
<li><p class="first">定数名: 定数のリストを与ることができます。ルールは変数と同じですが、試行関数を定数に関連付けることはできません。</p>
</li>
<li><p class="first">試行関数: 任意の変数に対して使用できます。試行関数は接頭辞 <tt class="docutils literal"><span class="pre">Test_</span></tt> とそれに続く対応する変数名によって識別されます。例えば <tt class="docutils literal"><span class="pre">Test_u</span></tt> 、 <tt class="docutils literal"><span class="pre">Test_v</span></tt> 、 <tt class="docutils literal"><span class="pre">Test_p</span></tt> 、 <tt class="docutils literal"><span class="pre">Test_pressure</span></tt> 、 <tt class="docutils literal"><span class="pre">Test_electric_field</span></tt> のようなものです。接触モデルの場合、2次の試行関数は <tt class="docutils literal"><span class="pre">Test2_</span></tt> と表記されその後ろに変数名が続きます。</p>
</li>
<li><p class="first">勾配: 変数または試行関数の空間的な勾配は、 <tt class="docutils literal"><span class="pre">Grad_</span></tt> を変数名か <tt class="docutils literal"><span class="pre">Test_</span></tt> 、 <tt class="docutils literal"><span class="pre">Test2_</span></tt> の接頭辞にすることで表現できます。FEM変数でのみ使用可能です。たとえば、 <tt class="docutils literal"><span class="pre">Grad_u</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_pressure</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_electric_field</span></tt> 、および <tt class="docutils literal"><span class="pre">Grad_Test_u</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_Test2_v</span></tt> です。ベクトルの場合、 <tt class="docutils literal"><span class="pre">Div_u</span></tt> と <tt class="docutils literal"><span class="pre">Div_Test_u</span></tt> は、それぞれ <tt class="docutils literal"><span class="pre">Trace(Grad_u)</span></tt> と <tt class="docutils literal"><span class="pre">Trace(Grad_Test_u)</span></tt> と等価です。</p>
</li>
<li><p class="first">Hessian: 変数または試行関数のHessian行列は、<tt class="docutils literal"><span class="pre">Hess_</span></tt> を変数名または <tt class="docutils literal"><span class="pre">Test_</span></tt> または <tt class="docutils literal"><span class="pre">Test2_</span></tt> の接頭辞にすることで表現できます。FEM変数でのみ使用可能です。たとえば、 <tt class="docutils literal"><span class="pre">Hess_u</span></tt>、 <tt class="docutils literal"><span class="pre">Hess_v</span></tt>、 <tt class="docutils literal"><span class="pre">Hess_p</span></tt>、 <tt class="docutils literal"><span class="pre">Hess_Test2_v</span></tt>、 <tt class="docutils literal"><span class="pre">Hess_Test_p</span></tt>、 <tt class="docutils literal"><span class="pre">Hess_Test_pressure</span></tt> などです。</p>
</li>
<li><p class="first">いくつかの定義済みのスカラ関数( <tt class="docutils literal"><span class="pre">sin(t)</span></tt> 、 <tt class="docutils literal"><span class="pre">cos(t)</span></tt> 、 <tt class="docutils literal"><span class="pre">pow(t,u)</span></tt> 、 <tt class="docutils literal"><span class="pre">sqrt(t)</span></tt> 、 <tt class="docutils literal"><span class="pre">sqr(t)</span></tt> 、 <tt class="docutils literal"><span class="pre">Heaviside(t)</span></tt> 、...)。スカラー関数は、スカラーまたはベクトル/行列/テンソル式に適用することができます。成分ごとに適用されます。 2つの引数( <tt class="docutils literal"><span class="pre">pow(t,u)</span></tt> 、 <tt class="docutils literal"><span class="pre">min(t,u)</span></tt> ...)を持つ関数の場合、 2つの非スカラー引数が渡された場合、次元は同じでなければなりません。たとえば、 &#8220;max([1; 2]、[0; 3])&#8221; は &#8220;[1;3]&#8221; を返します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">:</span></tt>, <tt class="docutils literal"><span class="pre">.</span></tt>, <tt class="docutils literal"><span class="pre">.*</span></tt>, <tt class="docutils literal"><span class="pre">./</span></tt>, <tt class="docutils literal"><span class="pre">&#64;</span></tt>, <tt class="docutils literal"><span class="pre">'</span></tt> となります。</p>
</li>
<li><p class="first">いくつかの定数: <tt class="docutils literal"><span class="pre">pi</span></tt> 、 <tt class="docutils literal"><span class="pre">meshdim</span></tt> （現在のメッシュの次元）、変数 <tt class="docutils literal"><span class="pre">u</span></tt> の大きさ <tt class="docutils literal"><span class="pre">qdim(u)</span></tt> と <tt class="docutils literal"><span class="pre">qdims(u)</span></tt> （固定サイズの変数のサイズとFEM変数のベクトルフィールドの次元）、 <tt class="docutils literal"><span class="pre">Id(n)</span></tt> は <img class="math" src="../_images/math/93f761f7fc79f2bec21a2f31c896840d6f36cdc0.png" alt="n\times n" style="vertical-align: 0px"/> 次の単位行列です。</p>
</li>
<li><p class="first">括弧は標準的な方法で操作の順序を変更するために使用できます。例えば <tt class="docutils literal"><span class="pre">(1+2)*4</span></tt> や <tt class="docutils literal"><span class="pre">(u+v)*Test_u</span></tt> は有効な式です。</p>
</li>
<li><p class="first">ベクトル/行列/テンソルの成分へのアクセスは、左括弧、成分のリスト、右括弧の項をたどることによって行うことができます。たとえば、 <tt class="docutils literal"><span class="pre">[1,1,2](3)</span></tt> は正しく <tt class="docutils literal"><span class="pre">2</span></tt> を返します。インデックスは1で始まることに注意してください（C++やPythonインタフェースでも）。コロンを使うことでMatlabのような構文でインデックス先の値を置き換えることができます。</p>
</li>
<li><p class="first">陽なベクトル: 例えば <tt class="docutils literal"><span class="pre">[1;2;3;4]</span></tt> はサイズが4の陽なベクトルです。各成分は式になります。</p>
</li>
<li><p class="first">陽行列: たとえば <tt class="docutils literal"><span class="pre">[1,3;2,4]</span></tt> と <tt class="docutils literal"><span class="pre">[[1,2],[3,4]]</span></tt> は同じ2x2行列を表します。各成分は式になります。</p>
</li>
<li><p class="first">陽な4次テンソル: 例えば入れ子形式の陽な3x2x2x2の4次テンソルは: <tt class="docutils literal"><span class="pre">[[[[1,2,3],[1,2,3]],[[1,2,3],[1,2,3]]],[[[1,2,3],[1,2,3]],[[1,2,3],[1,2,3]]]]</span></tt> です。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">X</span></tt> は実要素上の現在の座標です。 <tt class="docutils literal"><span class="pre">X(i)</span></tt> はi番目の要素です。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Normal</span></tt> は領域境界に積分するときの境界に対する外向きの単位法線ベクトル、または <tt class="docutils literal"><span class="pre">mesh_im_level_set</span></tt> メソッドでレベル集合に積分するときのレベル集合への単位法線ベクトルです。後者の場合、法線ベクトルはレベル集合関数勾配の方向にあります。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Reshape(t,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">...)</span></tt>: ベクトル/行列/テンソルを変形します。 <em>GetFEM++</em> のすべてのテンソルはFortranの次数で格納されることに留意してください。</p>
</li>
<li><p class="first">ある数の線形と非線形の演算子（ <tt class="docutils literal"><span class="pre">Trace</span></tt>、 <tt class="docutils literal"><span class="pre">Norm</span></tt>、 <tt class="docutils literal"><span class="pre">Det</span></tt>、 <tt class="docutils literal"><span class="pre">Deviator</span></tt>、 <tt class="docutils literal"><span class="pre">Contract</span></tt> など）。非線形演算子は試行関数には適用できません。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Diff(expression、variable)</span></tt>: 変数に対する陽な微分可能性（記号による微分）。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Diff(expression,</span> <span class="pre">variable,</span> <span class="pre">direction)</span></tt>: <tt class="docutils literal"><span class="pre">direction</span></tt> 方向の <tt class="docutils literal"><span class="pre">variable</span></tt> に対して <tt class="docutils literal"><span class="pre">expression</span></tt> の導関数を計算します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Grad(expression)</span></tt>: 可能であれば、与えられた式の勾配を記号的に微分します。</p>
</li>
<li><p class="first">マクロ定義の可能性（model内では、ga_workspaceオブジェクトまたは構築文字列内で直接）。マクロは、字句解析フェーズでインライン展開された有効な式でなければなりません（数回使用すると、計算はコンパイル段階で自動的に因数分解されます）。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Interpolate(variable,</span> <span class="pre">transformation)</span></tt>: 他の要素や別のメッシュ上の同じメッシュ上で変数を補間したり試行関数を補うことができる強力な演算。 <tt class="docutils literal"><span class="pre">transformation</span></tt> は、現在の点から補間を実行する点までのマップを記述するworkspaceまたはmodelオブジェクトによって格納されるオブジェクトです。この機能は、例えば、周期的な条件を規定するため、または異なるメッシュ上に定義された2つの有限要素空間のモルタル行列を計算するため、またはより一般的には流体構造相互作用のような架空の領域法のために使用できます。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Elementary_transformation(variable,</span> <span class="pre">transformation)</span></tt>: 要素水準で定義された線形変換を許可します（つまり、Gauss積分点基準では定義できません）。この機能は、主にプレート要素の縮小（回転RT0などの低水準のベクトル要素への投影）を定義するために追加されました。 <tt class="docutils literal"><span class="pre">transformation</span></tt> は、特定の要素の変換を記述するworkspaceやmodelオブジェクトによって格納されるオブジェクトです。</p>
</li>
<li><p class="first">二重積分計算またはカーネル/畳み込み/積分積分による2つの変数の結合のための2つの領域の直接積に対する積分の可能です。これにより、次のような表現が可能になります。<img class="math" src="../_images/math/25c056f01b2d920f07a2a9bee3a455aa739c218a.png" alt="\Omega_1" style="vertical-align: -4px"/> 上と <img class="math" src="../_images/math/1705dcf5b6ed693e2aaea2fda973ea0b976433db.png" alt="\Omega_2" style="vertical-align: -3px"/> 上の2つの領域で <img class="math" src="../_images/math/89e5a3f997b03e8f485ade1fa8c8f34fdae4da18.png" alt="\displaystyle\int_{\Omega_1}\int_{\Omega_2}k(x,y)u(x)v(y)dydx" style="vertical-align: -19px"/> 同じにしろ違うにしろ固有のメッシュと積分手法を持つことができます。ここで、 <img class="math" src="../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u" style="vertical-align: 0px"/> は <img class="math" src="../_images/math/25c056f01b2d920f07a2a9bee3a455aa739c218a.png" alt="\Omega_1" style="vertical-align: -4px"/> 上で定義された変数で <img class="math" src="../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v" style="vertical-align: 0px"/> は <img class="math" src="../_images/math/1705dcf5b6ed693e2aaea2fda973ea0b976433db.png" alt="\Omega_2" style="vertical-align: -3px"/> 上で定義された変数です。キーワード <tt class="docutils literal"><span class="pre">Secondary_domain(変数)</span></tt> を使用すると、積分の第2領域上の変数にアクセスできます。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="some-basic-examples">
<h2>いくつかの基本的な例<a class="headerlink" href="#some-basic-examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>領域 <img class="math" src="../_images/math/9e2b196e9b7e57d1ec99f6534c581ea9759d2170.png" alt="\Omega" style="vertical-align: 0px"/> 上のPoisson問題の弱定式化。</p>
<div class="math">
<p><img src="../_images/math/c69e02bd0cfefd5bce759e6b63fc5179d30116d5.png" alt="-\mbox{div } \nabla u = f, \mbox{ in } \Omega,"/></p>
</div><p><img class="math" src="../_images/math/6720af89712e36d5af405fb7adf80ec1f04b211a.png" alt="\partial\Omega" style="vertical-align: -1px"/> 上のDirichletの境界条件 <img class="math" src="../_images/math/7d43eae6892d884f8e8f4345b93c83fcf7db3481.png" alt="u = 0" style="vertical-align: 0px"/> は古典的な表現です</p>
<div class="math">
<p><img src="../_images/math/e079a30851f34cce3d3a0aad36ad8f81263e3b66.png" alt="\int_{\Omega} \nabla u\cdot \nabla v dx = \int_{\Omega} f v dx,"/></p>
</div><p>すべての試行関数について <img class="math" src="../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v" style="vertical-align: 0px"/> が <img class="math" src="../_images/math/6720af89712e36d5af405fb7adf80ec1f04b211a.png" alt="\partial\Omega" style="vertical-align: -1px"/> から消えます。構築文字列の対応する式は次の通りです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Grad_u</span><span class="p">.</span><span class="n">Grad_Test_u</span> <span class="o">-</span> <span class="n">my_f</span><span class="o">*</span><span class="n">Test_u</span>
</pre></div>
</div>
<p>ここで、 <tt class="docutils literal"><span class="pre">my_f</span></tt> はソース項の式です。式が次の通りです。</p>
<div class="math">
<p><img src="../_images/math/b095e77c2d964b6902422a435901d6d8abc1b869.png" alt="-\mbox{div } a\nabla u = f, \mbox{ in } \Omega,"/></p>
</div><p><tt class="docutils literal"><span class="pre">a</span></tt> がスカラー係数の場合、対応する構築文字列は</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">a</span><span class="o">*</span><span class="n">Grad_u</span><span class="p">.</span><span class="n">Grad_Test_u</span> <span class="o">-</span> <span class="n">my_f</span><span class="o">*</span><span class="n">Test_u</span>
</pre></div>
</div>
<p>で <tt class="docutils literal"><span class="pre">a</span></tt> がスカラー定数またはスカラー項として宣言されなければなりません。それを陽に記述することも可能です。例えば、問題</p>
<div class="math">
<p><img src="../_images/math/5ffbdab90bb325b0c95363f1c58f59d98907eea8.png" alt="-\mbox{div } \sin(x_1+x_2)\nabla u = f, \mbox{ in } \Omega,"/></p>
</div><p>では <img class="math" src="../_images/math/495ec646b2b1cfe91eb7fd0b408ed572aa011828.png" alt="x_1, x_2" style="vertical-align: -4px"/> はメッシュ上の座標で次のように表現することができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">sin</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">Grad_u</span><span class="p">.</span><span class="n">Grad_Test_u</span> <span class="o">-</span> <span class="n">my_f</span><span class="o">*</span><span class="n">Test_u</span>
</pre></div>
</div>
<p>別の古典的な方程式は線形弾性です。</p>
<div class="math">
<p><img src="../_images/math/d0fd930f89710672af61587bb3203789b1a8c3ff.png" alt="-\mbox{div } \sigma(u) = f, \mbox{ in } \Omega,"/></p>
</div><p>等価線形弾性の場合には、ベクトル場 <img class="math" src="../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u" style="vertical-align: 0px"/> と <img class="math" src="../_images/math/f6441ba16f1e778b63716920d7793e69859a6dcd.png" alt="\sigma(u) = \lambda \mbox{div } u + \mu (\nabla u + (\nabla u)^T)" style="vertical-align: -4px"/> が考えられています。弱定式化の記述に対応する構築文字列は以下のように書くことができます。</p>
<div class="highlight-c++"><pre>(lambda*Trace(Grad_u)*Id(qdim(u)) + mu*(Grad_u+Grad_u&#x27;)):Grad_Test_u - my_f.Test_u</pre>
</div>
<p>または次の通りです。</p>
<div class="highlight-c++"><pre>lambda*Div_u*Div_Test_u + mu*(Grad_u + Grad_u&#x27;):Grad_Test_u - my_f.Test_u</pre>
</div>
<p>ここでもまた、いくつかの問題を結合するために、係数 <tt class="docutils literal"><span class="pre">lambda</span></tt> と <tt class="docutils literal"><span class="pre">mu</span></tt> に定数、あるいはスカラーフィールドや陽表現、あるいは他の変数からの式を与えますことができます。たとえば、係数が温度場に依存する場合、次のように書くことができます。</p>
<div class="highlight-c++"><pre>my_f1(theta)*Div_u*Div_Test_u
+ my_f2(theta)*(Grad_u + Grad_u&#x27;):Grad_Test_u - my_f.Grad_Test_u</pre>
</div>
<p>ここで、 <tt class="docutils literal"><span class="pre">theta</span></tt> は、Poisson方程式の解である温度です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Grad_theta</span><span class="p">.</span><span class="n">Grad_Test_theta</span> <span class="o">-</span> <span class="n">my_f</span><span class="o">*</span><span class="n">Grad_Test_theta</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">my_f1</span></tt> と <tt class="docutils literal"><span class="pre">my_f2</span></tt> はいくつかの与えられた関数です。その場合、2つの関数 <tt class="docutils literal"><span class="pre">my_f1</span></tt> と <tt class="docutils literal"><span class="pre">my_f2</span></tt> が線形であっても、結合されているために問題は非線形であることに注意してください。</p>
</div>
<div class="section" id="derivation-order-and-symbolic-differentiation">
<h2>微分次数と記号による微分<a class="headerlink" href="#derivation-order-and-symbolic-differentiation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>構築文字列の微分次数は自動的に検出されます。試行関数が見つからない場合、次数は0（ポテンシャルエネルギー）とみなされ、1次試行関数が見つかった場合、その次数は1（弱定式化）とみなされ、1次と2次の両方の試行関数が見つかると、次数は2（接線系）とみなされます。</p>
<p>構築（次のセクションを参照）を実行するには、次数（0,1または2）を指定する必要があります。次数1の文字列が提供され、次数2の構築が必要な場合は、式の記号微分が行われます。次数0の文字列が提供され、次数1または2の構築が必要な場合も同じです。もちろん、その逆は真ではありません。次数1の式が指定され、次数0の構築が予想される場合、積分は行われません。任意の弱定式化はポテンシャルエネルギーから微分する必要はないので、これは一般に必要ではありません。</p>
<p>汎用構築を使用する標準的な方法は、次数1の式（すなわち、弱定式化）を与えることです。ポテンシャルエネルギーが存在する場合、それを供給することが可能です。しかし、複雑な表現をもたらす接線系を得るためには2回導かれます。非線形問題では、2次式を直接指定することはできません。その理由は、残差を得るために弱定式化が必要であるからです。したがって、対応する次数1の項を持たないで接線項を使用することはできません。</p>
<p>重要な注意事項: 結合した問題については、グローバルポテンシャルはしばしば存在しないことに注意してください。ポテンシャルが直接定義された問題の部分を結合するのは難しい場合があります。これを説明するために、いくつかのパラメータ（たとえば弾性係数）を持つポテンシャルを定義し、その係数が別の変数との変動の変化で構成されている場合、弱定式化はもちろんポテンシャルの導関数ではありません、一般的に意味を持たない係数に関するものです。ポテンシャルの定義が例外でなければならないのはこれが理由です。</p>
</div>
<div class="section" id="c-call-of-the-assembly">
<h2>構築のためのC ++呼び出し<a class="headerlink" href="#c-call-of-the-assembly" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>汎用構築を使用する最も自然な方法はmodelオブジェクトの汎用構築要素を使用することです（ <a class="reference internal" href="model_generic_assembly.html#ud-model-generic-assembly"><em>汎用的な構築ブリック要素</em></a> 節を参照してください）。しかし、高水準汎用構築を単独で使用することも可能です。</p>
<p>汎用構築は <tt class="file docutils literal"><span class="pre">getfem/getfem_generic_assembly.h</span></tt> で定義されたオブジェクト <tt class="docutils literal"><span class="pre">getfem::ga_workspace</span></tt> によって駆動されます。</p>
<p><tt class="docutils literal"><span class="pre">getfem::ga_workspace</span></tt> オブジェクトを定義する方法は2つあります。それはmodelに依存し（ <a class="reference internal" href="model.html#ud-model"><em>モデル記述と基本モデルブリック要素</em></a> を参照）次のように定義する必要があります。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">ga_workspace</span> <span class="n">workspace</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">model</span></tt> はあらかじめ <tt class="docutils literal"><span class="pre">getfem::model</span></tt> でオブジェクトとしてを定義されています。その場合、考慮する変数と定数はmodelの一部です。第2の方法は次に示す方法によって独立した <tt class="docutils literal"><span class="pre">getfem::ga_workspace</span></tt> オブジェクトを定義する方法です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">ga_workspace</span> <span class="n">workspace</span><span class="p">;</span>
</pre></div>
</div>
<p>その場合、変数と定数をworkspaceに追加する必要があります。これは以下の方法により実行できます:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mf</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">);</span>

<span class="n">workspace</span><span class="p">.</span><span class="n">add_fixed_size_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">);</span>

<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_constant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mf</span><span class="p">,</span> <span class="n">V</span><span class="p">);</span>

<span class="n">workspace</span><span class="p">.</span><span class="n">add_fixed_size_constant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">V</span><span class="p">);</span>

<span class="n">workspace</span><span class="p">.</span><span class="n">add_im_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">imd</span><span class="p">,</span> <span class="n">V</span><span class="p">);</span>
</pre></div>
</div>
<p>ここで、 <tt class="docutils literal"><span class="pre">name</span></tt> は変数/定数名です（次の節の名前の制限を参照）。 <tt class="docutils literal"><span class="pre">mf</span></tt> は有限要素法を記述する <tt class="docutils literal"><span class="pre">getfem::mesh_fem</span></tt> オブジェクトです。 <tt class="docutils literal"><span class="pre">I</span></tt> は構築られたベクトル/行列上の変数の間隔を示す <tt class="docutils literal"><span class="pre">gmm::sub_interval</span></tt> クラスのオブジェクトであり、 <tt class="docutils literal"><span class="pre">V</span></tt> は変数/変数の値である <tt class="docutils literal"><span class="pre">getfem::base_vector</span></tt> です。最後のメソッドは、 <tt class="docutils literal"><span class="pre">im_data</span></tt> オブジェクト <tt class="docutils literal"><span class="pre">imd</span></tt> に定義された定数を追加します。これは、 <tt class="docutils literal"><span class="pre">mesh_im</span></tt> オブジェクトの積分点にスカラー/ベクトル/テンソルフィールド情報を格納することを可能にします。</p>
<p>一度宣言され、一度変数と定数が宣言されると、構築文字列を次のようにしてworkspaceに追加することができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="s">&quot;my expression&quot;</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="n">rg</span> <span class="o">=</span> <span class="n">all_convexes</span><span class="p">());</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">mim</span></tt> に対応するメッシュのオプションの有効な領域が <tt class="docutils literal"><span class="pre">mf</span></tt> にある場合、 <tt class="docutils literal"><span class="pre">mf</span></tt> は <tt class="docutils literal"><span class="pre">getfem::mesh_im</span></tt> オブジェクトと <tt class="docutils literal"><span class="pre">rg</span></tt> です。</p>
<p>前のセクションで説明したように、文字列の順序が自動的に検出され、対応する接線項を得るために記号的な微分が実行されます。</p>
<p>構築文字列がworkspaceに追加されると、以下を呼び出すことができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">order</span></tt> は0（ポテンシャルエネルギー）、1（残差ベクトル）または2（線形問題の接線項または剛性行列）のいずれかでなければなりません。構築の結果は次のように利用できます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">assembled_potential</span><span class="p">()</span> <span class="c1">// For order = 0</span>

<span class="n">workspace</span><span class="p">.</span><span class="n">assembled_vector</span><span class="p">()</span>    <span class="c1">// For order = 1</span>

<span class="n">workspace</span><span class="p">.</span><span class="n">assembled_matrix</span><span class="p">()</span>    <span class="c1">// For order = 2</span>
</pre></div>
</div>
<p>デフォルトでは、アセンブルされたポテンシャル、ベクトル、およびマトリックスは、構築の開始時にゼロに初期化されます。ただし、増分構築を実行するために、構築ベクトルと行列を外部ベクトルと行列に設定することが可能です（お勧めします）。 2つの方法により構築が可能です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_vector</span><span class="p">(</span><span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">);</span>

<span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_matrix</span><span class="p">(</span><span class="n">getfem</span><span class="o">::</span><span class="n">model_real_sparse_matrix</span> <span class="o">&amp;</span><span class="n">K</span><span class="p">);</span>
</pre></div>
</div>
<p>そうすることができます。正しい次元のベクトルと行列を与えるように注意してください。</p>
<p>また、次のメソッドにより</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">clear_expressions</span><span class="p">();</span>
</pre></div>
</div>
<p>付属のすべての式を取り消すことができ、別の構築で同じworkspaceを再利用することができます。</p>
<p>汎用構築を Python/Scilab/Matlab インタフェースから呼び出すこともできます。詳細はインタフェースの <tt class="docutils literal"><span class="pre">gf_asm</span></tt> コマンドを参照してください。</p>
</div>
<div class="section" id="c-assembly-examples">
<h2>C ++構築の例<a class="headerlink" href="#c-assembly-examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>第1の例として、Poisson問題の構築を紹介します。</p>
<div class="math">
<p><img src="../_images/math/c69e02bd0cfefd5bce759e6b63fc5179d30116d5.png" alt="-\mbox{div } \nabla u = f, \mbox{ in } \Omega,"/></p>
</div><p>剛性行列は次式で与えられ</p>
<div class="math">
<p><img src="../_images/math/34dd8e7987f5e7d7da51410542875ea140893157.png" alt="K_{i,j} = \int_{\Omega} \nabla \varphi_i \cdot \nabla \varphi_j dx,"/></p>
</div><p>次のコードでアセンブルされます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">ga_workspace</span> <span class="n">workspace</span><span class="p">;</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">size_type</span> <span class="n">nbdof</span> <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">nb_dof</span><span class="p">();</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">U</span><span class="p">(</span><span class="n">nbdof</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">mf</span><span class="p">,</span> <span class="n">gmm</span><span class="o">::</span><span class="n">sub_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbdof</span><span class="p">),</span> <span class="n">U</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="s">&quot;Grad_u.Grad_Test_u&quot;</span><span class="p">,</span> <span class="n">mim</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">model_real_sparse_matrix</span> <span class="n">K</span><span class="p">(</span><span class="n">nbdof</span><span class="p">,</span> <span class="n">nbdof</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_matrix</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>もちろん、 <tt class="docutils literal"><span class="pre">mf</span></tt> はすでに宣言された <tt class="docutils literal"><span class="pre">getfem::mesh_fem</span></tt> オブジェクトであり、 <tt class="docutils literal"><span class="pre">mim</span></tt> はすでに同じメッシュ上に <tt class="docutils literal"><span class="pre">getfem::mesh_im</span></tt> オブジェクトとして宣言されています。変数の値は、問題の線形性のために実際に使用するわけではないことに注意してください。使用されない変数の値として <tt class="docutils literal"><span class="pre">getfem::base_vector(nbdof)</span></tt> を渡すことができます。また、構築-文字列の結果とまったく同じ結果が得られる2つの式は、 <tt class="docutils literal"><span class="pre">&quot;Grad_Test2_u.Grad_Test_u&quot;</span></tt> すなわち、2次式）または <tt class="docutils literal"><span class="pre">&quot;Norm_sqr(Grad_u)/2&quot;</span></tt> （すなわち、ポテンシャル）。 <tt class="docutils literal"><span class="pre">&quot;Grad_u.Grad_u/2&quot;</span></tt> か2次元問題のための  <tt class="docutils literal"><span class="pre">&quot;[Grad_u(1),</span> <span class="pre">Grad_u(2)].[Grad_Test_u(1),</span> <span class="pre">Grad_Test_u(2)]&quot;</span></tt> などでも同じ結果が得られます。しかしながら、0次または2次の表現を使用する特別な理由がなければ、1次の表現（弱定式化）を与えることが推奨されます。</p>
<p>第2の例として、連成問題である非圧縮性弾性の混合問題を考えます</p>
<div class="math">
<p><img src="../_images/math/91af0d98ebc00651a4d843ca8d069de6554300a2.png" alt="-\mbox{div}(\mu(\nabla u + (\nabla u)^T - p I_d)  = f, \mbox{ in } \Omega,

\mbox{div } u = 0."/></p>
</div><p>ここで <tt class="docutils literal"><span class="pre">u</span></tt> はベクトル値の変位であり、 <tt class="docutils literal"><span class="pre">p</span></tt> は圧力です。結合されたシステム全体のマトリックスは以下のように構築します。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">ga_workspace</span> <span class="n">workspace</span><span class="p">;</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">size_type</span> <span class="n">nbdofu</span> <span class="o">=</span> <span class="n">mf_u</span><span class="p">.</span><span class="n">nb_dof</span><span class="p">();</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">size_type</span> <span class="n">nbdofp</span> <span class="o">=</span> <span class="n">mf_p</span><span class="p">.</span><span class="n">nb_dof</span><span class="p">();</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">U</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">P</span><span class="p">(</span><span class="n">nbdofp</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">vmu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">vmu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span><span class="p">;</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">mf_u</span><span class="p">,</span> <span class="n">gmm</span><span class="o">::</span><span class="n">sub_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbdofu</span><span class="p">),</span> <span class="n">U</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="n">mf_p</span><span class="p">,</span> <span class="n">gmm</span><span class="o">::</span><span class="n">sub_interval</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">,</span> <span class="n">nbdofp</span><span class="p">),</span> <span class="n">P</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fixed_size_constant</span><span class="p">(</span><span class="s">&quot;mu&quot;</span><span class="p">,</span> <span class="n">vmu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="s">&quot;2*mu*Sym(Grad_u):Grad_Test_u&quot;</span>
                      <span class="s">&quot;- p*Trace(Grad_Test_u) - Test_p*Trace(Grad_u)&quot;</span><span class="p">,</span> <span class="n">mim</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">model_real_sparse_matrix</span> <span class="n">K</span><span class="p">(</span><span class="n">nbdofu</span><span class="o">+</span><span class="n">nbdofp</span><span class="p">,</span> <span class="n">nbdofu</span><span class="o">+</span><span class="n">nbdofp</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_matrix</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>ここで <tt class="docutils literal"><span class="pre">mf_u</span></tt> と <tt class="docutils literal"><span class="pre">mf_p</span></tt> はすでに同じメッシュに定義されている <tt class="docutils literal"><span class="pre">getfem::mesh_fem</span></tt> オブジェクトの一部で、 <tt class="docutils literal"><span class="pre">mim</span></tt> は定義済みの <tt class="docutils literal"><span class="pre">getfem::mesh_im</span></tt> オブジェクト、  <tt class="docutils literal"><span class="pre">mu</span></tt> はLameの弾性定数です。このシステムの部分行列の構築を別々に行うことも可能です。</p>
<p>ソース項の構築方法を見てみましょう。ボリュームソース項の弱定式化は次のとおりです。</p>
<div class="math">
<p><img src="../_images/math/a396db161a14675475d3d2c6a2eb3ee167ad8755.png" alt="\int_{\Omega} fv dx"/></p>
</div><p>ここで、 <img class="math" src="../_images/math/bb2c93730dbb48558bb3c4738c956c4e8f816437.png" alt="f" style="vertical-align: -4px"/> はソース項であり、 <img class="math" src="../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v" style="vertical-align: 0px"/> は試行関数です。この構築は次のように記述します。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">ga_workspace</span> <span class="n">workspace</span><span class="p">;</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">size_type</span> <span class="n">nbdofu</span> <span class="o">=</span> <span class="n">mf_u</span><span class="p">.</span><span class="n">nb_dof</span><span class="p">();</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">U</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">mf_u</span><span class="p">,</span> <span class="n">gmm</span><span class="o">::</span><span class="n">sub_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbdofu</span><span class="p">),</span> <span class="n">U</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_constant</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">mf_data</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="s">&quot;f*Test_u&quot;</span><span class="p">,</span> <span class="n">mim</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">L</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_vector</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>ソース項が有限要素 <tt class="docutils literal"><span class="pre">mf_data</span></tt> とそれに対応する自由度のベクトル <tt class="docutils literal"><span class="pre">F</span></tt> で記述されている場合。陽なソース項を定義することも可能です。例えば</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">ga_workspace</span> <span class="n">workspace</span><span class="p">;</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">size_type</span> <span class="n">nbdofu</span> <span class="o">=</span> <span class="n">mf_u</span><span class="p">.</span><span class="n">nb_dof</span><span class="p">();</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">U</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">mf_u</span><span class="p">,</span> <span class="n">gmm</span><span class="o">::</span><span class="n">sub_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbdofu</span><span class="p">),</span> <span class="n">U</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="s">&quot;sin(X(1)+X(2))*Test_u&quot;</span><span class="p">,</span> <span class="n">mim</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">L</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_vector</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>も有効です。ソース項が境界項（Neumann条件の場合）である場合、唯一の違いは、境界に対応するメッシュ領域を次のように与えられなければならないことです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="s">&quot;sin(X(1)+X(2))*Test_u&quot;</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
</pre></div>
</div>
<p>ここで <tt class="docutils literal"><span class="pre">region</span></tt> はメッシュ領域番号です。</p>
<p>別の例として、単純な非線形弾性問題を説明します。Saint-Venant Kirchhoff構成則を考えると、次のような基準構成体 <img class="math" src="../_images/math/9e2b196e9b7e57d1ec99f6534c581ea9759d2170.png" alt="\Omega" style="vertical-align: 0px"/> 上の弾性エネルギーとみなす必要があります</p>
<div class="math">
<p><img src="../_images/math/161e1f8957cc317aea14d2f72600c90e167d7130.png" alt="\int_{\Omega} \Frac{\lambda}{2} (\mbox{tr}(E))^2 + \mu \mbox{tr}(E^2) dx"/></p>
</div><p>ここで <img class="math" src="../_images/math/9a15a07f3bbe7e6adf0fea5f58e4559bcfb45037.png" alt="\lambda, \mu" style="vertical-align: -4px"/> は Lamé 定数で <img class="math" src="../_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E" style="vertical-align: 0px"/> は、式 <img class="math" src="../_images/math/3345b40f15d097162bb002fb1472f8b54f962819.png" alt="E = (\nabla u + (\nabla u)^T + (\nabla u)^T\nabla u)/2" style="vertical-align: -5px"/> で与えられる歪みテンソルです。</p>
<p>この問題では、対応する接線問題を以下のように構築することが可能です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">ga_workspace</span> <span class="n">workspace</span><span class="p">;</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">size_type</span> <span class="n">nbdofu</span> <span class="o">=</span> <span class="n">mf_u</span><span class="p">.</span><span class="n">nb_dof</span><span class="p">();</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">vlambda</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">vlambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">;</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">vmu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">vmu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span><span class="p">;</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">mf_u</span><span class="p">,</span> <span class="n">gmm</span><span class="o">::</span><span class="n">sub_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbdofu</span><span class="p">),</span> <span class="n">U</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fixed_size_constant</span><span class="p">(</span><span class="s">&quot;lambda&quot;</span><span class="p">,</span> <span class="n">vlambda</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fixed_size_constant</span><span class="p">(</span><span class="s">&quot;mu&quot;</span><span class="p">,</span> <span class="n">vmu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="s">&quot;lambda*sqr(Trace(Grad_u+Grad_u&#39;+Grad_u&#39;*Grad_u))&quot;</span>
                         <span class="s">&quot;+ mu*Trace((Grad_u+Grad_u&#39;+Grad_u&#39;*Grad_u)&quot;</span>
                         <span class="s">&quot;*(Grad_u+Grad_u&#39;+Grad_u&#39;*Grad_u))&quot;</span><span class="p">,</span> <span class="n">mim</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">L</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_vector</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">model_real_sparse_matrix</span> <span class="n">K</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">,</span> <span class="n">nbdofu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_matrix</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>この非線形問題を解くためにNewton-Raphsonアルゴリズムを適応します。もちろん、表現はより反復的であり、いくつかの中間非線形演算子を定義することが望ましいです。ただし、繰り返し式は自動的に検出され、構築内で1回だけ計算されます。</p>
<p>最後の例は、4次問題の剛性行列を構築するKirchhoff-Love板の問題です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">ga_workspace</span> <span class="n">workspace</span><span class="p">;</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">size_type</span> <span class="n">nbdofu</span> <span class="o">=</span> <span class="n">mf_u</span><span class="p">.</span><span class="n">nb_dof</span><span class="p">();</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">vD</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">vD</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">base_vector</span> <span class="n">vnu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">vnu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nu</span><span class="p">;</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fem_variable</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">mf_u</span><span class="p">,</span> <span class="n">gmm</span><span class="o">::</span><span class="n">sub_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbdofu</span><span class="p">),</span> <span class="n">U</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fixed_size_constant</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="n">vD</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_fixed_size_constant</span><span class="p">(</span><span class="s">&quot;nu&quot;</span><span class="p">,</span> <span class="n">vnu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="s">&quot;D*(1-nu)*(Hess_u:Hess_Test_u) -&quot;</span>
                         <span class="s">&quot;D*nu*Trace(Hess_u)*Trace(Hess_Test_u)&quot;</span><span class="p">,</span> <span class="n">mim</span><span class="p">);</span>
<span class="n">getfem</span><span class="o">::</span><span class="n">model_real_sparse_matrix</span> <span class="n">K</span><span class="p">(</span><span class="n">nbdofu</span><span class="p">,</span> <span class="n">nbdofu</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">set_assembled_matrix</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
<span class="n">workspace</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">D</span></tt> は屈曲率であり、 <tt class="docutils literal"><span class="pre">nu</span></tt> はPoisson比です。</p>
</div>
<div class="section" id="script-languages-call-of-the-assembly">
<h2>構築言語のスクリプト言語からの呼び出し<a class="headerlink" href="#script-languages-call-of-the-assembly" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python、Scilab、Matlabのインタフェースで使用する場合は、それぞれのドキュメント、特に <tt class="docutils literal"><span class="pre">gf_asm</span></tt> コマンドと <tt class="docutils literal"><span class="pre">model</span></tt> オブジェクトを参照してください。</p>
</div>
<div class="section" id="the-tensors">
<h2>テンソル<a class="headerlink" href="#the-tensors" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的に、弱形式言語で操作されるのはテンソルです。例えば、スカラー式の0次テンソル（例えば、 <tt class="docutils literal"><span class="pre">3</span> <span class="pre">+</span> <span class="pre">sin(pi</span> <span class="pre">/</span> <span class="pre">2)</span></tt> ）、ベクトル式の1テンソル（ <tt class="docutils literal"><span class="pre">XX</span></tt> や <tt class="docutils literal"><span class="pre">u</span></tt> がスカラー変数の場合の <tt class="docutils literal"><span class="pre">Grad_u</span></tt> など）、行列表現の2テンソルなどです。効率性の理由から、言語はテンソルを最大6まで操作します。この言語は、6以上の次数のテンソルもサポートするように容易に拡張することができますが、非効率的な計算につながる可能性があります。式に試行関数が含まれている場合（ベクトルフィールド <tt class="docutils literal"><span class="pre">u</span></tt> の場合は <tt class="docutils literal"><span class="pre">Trace(Grad_Test_u)</span></tt> のように）、テンソルは暗黙的に補足成分を持つ各試行関数に対して計算が行われます。これは暗黙のうちに、操作されるテンソルの最大次数は実際には6であることを意味します（ <tt class="docutils literal"><span class="pre">Grad_Test_u.Grad_Test2_u</span></tt> には1次および2次試行関数のために2つの成分が暗黙に追加されています）。</p>
<p>弾性テンソルを表現するために、または汎用的なベクトル値の未知数の接線項を得るために、4次のテンソルが必要です。</p>
</div>
<div class="section" id="the-variables">
<h2>変数<a class="headerlink" href="#the-variables" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>変数のリストは <tt class="docutils literal"><span class="pre">ga_worspace</span></tt> オブジェクトに（直接またはmodelオブジェクトを通して）与えなければなりません。変数は有限要素法で記述されるか、未知数の単純なベクトルになります。これは、代数方程式をmodel上の部分方程式に結合することも可能であることを意味します。変数名は、文字（大文字小文字を区別する）またはアンダースコアの後に文字、数字、またはアンダースコアを続けて指定する必要があります。いくつかの名前は予約されていますが、これは演算子の名前（<tt class="docutils literal"><span class="pre">Det</span></tt>、 <tt class="docutils literal"><span class="pre">Norm</span></tt>、 <tt class="docutils literal"><span class="pre">Trace</span></tt>、 <tt class="docutils literal"><span class="pre">Deviator</span></tt> など）で、変数名として使用できません。名前は <tt class="docutils literal"><span class="pre">Test_</span></tt> 、 <tt class="docutils literal"><span class="pre">Test2_</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_</span></tt> 、 <tt class="docutils literal"><span class="pre">Div_</span></tt> または <tt class="docutils literal"><span class="pre">Hess_</span></tt> で始めることはできません。変数名はあらかじめ定義された関数（ <tt class="docutils literal"><span class="pre">sin</span></tt>、 <tt class="docutils literal"><span class="pre">cos</span></tt>、 <tt class="docutils literal"><span class="pre">acos</span></tt> ...）と定数（<tt class="docutils literal"><span class="pre">pi</span></tt> 、 <tt class="docutils literal"><span class="pre">Normal</span></tt> 、 <tt class="docutils literal"><span class="pre">X</span></tt> 、 <tt class="docutils literal"><span class="pre">Id</span></tt> ...）を使用することはできません。</p>
</div>
<div class="section" id="the-constants-or-data">
<h2>定数またはデータ<a class="headerlink" href="#the-constants-or-data" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>定数のリストを <tt class="docutils literal"><span class="pre">ga_worspace</span></tt> オブジェクトに与えることもできます。ルールは変数と同じですが、試行関数を定数に関連付けることはできず、定数に関して記号的な微分もありません。スカラー定数は、構成則に介入する係数を表すために定義されることが多いです。さらに、定数は、「im_data」オブジェクトを介して積分点上に定義されたいくつかのスカラー/ベクトル/テンソルフィールド（例えば、可塑性のような構成法の近似のいくつかの実装のために）です。</p>
</div>
<div class="section" id="test-functions">
<h2>試行関数<a class="headerlink" href="#test-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>各変数は、1次および2次の試行関数に関連付けられています。第1次試行関数は、弱定式化（それが存在すれば潜在的な式を微分する）で使用され、第2次試行関数は接触モデルで使用されます。変数 <tt class="docutils literal"><span class="pre">u</span></tt> に関連する試行関数は <tt class="docutils literal"><span class="pre">Test_u</span></tt> と <tt class="docutils literal"><span class="pre">Test2_u</span></tt> です。構築文字列は、試行関数に対して線形でなければなりません。構築文字列に <tt class="docutils literal"><span class="pre">Test_u</span></tt> という項が存在する結果として、式は変数 <tt class="docutils literal"><span class="pre">u</span></tt> に対応する有限要素の各試行関数について評価されます。与えられた要素において、有限要素が試行関数 <tt class="docutils literal"><span class="pre">N</span></tt> を持つ場合、 <tt class="docutils literal"><span class="pre">u</span></tt> がスカラ場である場合、 <tt class="docutils literal"><span class="pre">Test_u</span></tt> の値は現在の点上の各試行関数の値になります。ゆえに <tt class="docutils literal"><span class="pre">Test_u</span></tt> は <tt class="docutils literal"><span class="pre">N</span></tt> 値のベクトルの直交面を返します。もちろん、これは言語に暗黙のうちに書かれています。ゆえに、これについて気にする必要はありません。</p>
</div>
<div class="section" id="gradient">
<h2>勾配<a class="headerlink" href="#gradient" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>変数または試行関数の勾配は、 <tt class="docutils literal"><span class="pre">Grad_</span></tt> と変数名または <tt class="docutils literal"><span class="pre">Test_</span></tt> とそれに続く変数名によって識別されます。これは、FEM変数（または定数）でのみ使用できます。例えば、 <tt class="docutils literal"><span class="pre">Grad_u</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_v</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_p</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_pressure</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_electric_field</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_Test_u</span></tt> 、 <tt class="docutils literal"><span class="pre">Grad_Test_v</span></tt> 、<tt class="docutils literal"><span class="pre">Grad_Test_p</span></tt>、 <tt class="docutils literal"><span class="pre">Grad_Test_pressure</span></tt>、 <tt class="docutils literal"><span class="pre">Grad_Test_electric_field</span></tt> です。勾配は、スカラ変数のベクトルかベクトル場変数の行列のいずれかです。後者の場合、第1のインデックスはベクトルフィールド次元に対応し、第2のインデックスは部分導関数のインデックスに対応します。 <tt class="docutils literal"><span class="pre">Div_u</span></tt> と <tt class="docutils literal"><span class="pre">Div_Test_u</span></tt> は、それぞれ <tt class="docutils literal"><span class="pre">Trace(Grad_u)</span></tt> と <tt class="docutils literal"><span class="pre">Trace(Grad_Test_u)</span></tt> を最適化したショートカットです。</p>
</div>
<div class="section" id="hessian">
<h2>Hessian<a class="headerlink" href="#hessian" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>同様に、変数または試行関数のヘッセ行列は、 <tt class="docutils literal"><span class="pre">Hess_</span></tt> と変数名または <tt class="docutils literal"><span class="pre">Test_</span></tt> とそれに続く変数名によって識別されます。これは、FEM変数でのみ使用できます。例えば、 <tt class="docutils literal"><span class="pre">Hess_u</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_v</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_p</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_pressure</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_electric_field</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_Test_u</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_Test_v</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_Test_p</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_Test_pressure</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_Test_electric_field</span></tt> です。ヘッセ行列は、スカラ変数の行列またはベクトル場変数の3次テンソルのいずれかです。後者の場合、第1のインデックスはベクトル場次元に対応し、第2のインデックスは部分導関数に対応します。</p>
</div>
<div class="section" id="predefined-scalar-functions">
<h2>定義済みのスカラー関数<a class="headerlink" href="#predefined-scalar-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>特定の数の事前定義されたスカラー関数を使用することができます。網羅的なリストは以下の通りであり、そのほとんどは対応するC関数と同等です。</p>
<blockquote>
<div><ul class="simple">
<li><p class="first"><tt class="docutils literal"><span class="pre">sqr(t)</span></tt> （tの平方根、t*t に相当）、 <tt class="docutils literal"><span class="pre">pow(t,u)</span></tt> （tのu乗）、 <tt class="docutils literal"><span class="pre">sqrt(t)</span></tt> （tの平方根）、 <tt class="docutils literal"><span class="pre">exp(t)</span></tt> 、 <tt class="docutils literal"><span class="pre">log(t)</span></tt> 、 <tt class="docutils literal"><span class="pre">log10(t)</span></tt></p>
</li>
<li><tt class="docutils literal"><span class="pre">sin(t)</span></tt>, <tt class="docutils literal"><span class="pre">cos(t)</span></tt>, <tt class="docutils literal"><span class="pre">tan(t)</span></tt>, <tt class="docutils literal"><span class="pre">asin(t)</span></tt>, <tt class="docutils literal"><span class="pre">acos(t)</span></tt>, <tt class="docutils literal"><span class="pre">atan(t)</span></tt>, <tt class="docutils literal"><span class="pre">atan2(t,</span> <span class="pre">u)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">sinh(t)</span></tt>, <tt class="docutils literal"><span class="pre">cosh(t)</span></tt>, <tt class="docutils literal"><span class="pre">tanh(t)</span></tt>, <tt class="docutils literal"><span class="pre">asinh(t)</span></tt>, <tt class="docutils literal"><span class="pre">acosh(t)</span></tt>, <tt class="docutils literal"><span class="pre">atanh(t)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">erf(t)</span></tt>, <tt class="docutils literal"><span class="pre">erfc(t)</span></tt></li>
<li><p class="first"><tt class="docutils literal"><span class="pre">sinc(t)</span></tt> （基本的な正弦関数sin(t)/t）</p>
</li>
<li><tt class="docutils literal"><span class="pre">Heaviside(t)</span></tt> (<img class="math" src="../_images/math/4d155867a4929320a23d140a760b7b0d28455ce9.png" alt="0 \mbox{ for } t &lt; 0, 1 \mbox{ for } t \ge 0" style="vertical-align: -4px"/>)</li>
<li><tt class="docutils literal"><span class="pre">sign(t)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">abs(t)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">pos_part(t)</span></tt> (<img class="math" src="../_images/math/d60fc05f9dfede6101e141e240c13112ad9c6d4c.png" alt="tH(t)" style="vertical-align: -4px"/>)</li>
<li><tt class="docutils literal"><span class="pre">reg_pos_part(t,</span> <span class="pre">eps)</span></tt> (<img class="math" src="../_images/math/d0d1cafcde92f0bb408244a470e7e223637bbf6a.png" alt="(t-eps/2-t^2/(2eps))H(t-eps) + t^2H(t)/(2eps)" style="vertical-align: -5px"/>)</li>
<li><tt class="docutils literal"><span class="pre">neg_part(t)</span></tt> (<img class="math" src="../_images/math/c8b5866ceff9804b3891ffbe42e0cc9c89f5f264.png" alt="-tH(-t)" style="vertical-align: -4px"/>), <tt class="docutils literal"><span class="pre">max(t,</span> <span class="pre">u)</span></tt>, <tt class="docutils literal"><span class="pre">min(t,</span> <span class="pre">u)</span></tt></li>
</ul>
</div></blockquote>
<p>スカラ関数は、スカラー式に適用することもできますが、テンソル式に適用することもできます。 テンソル式に適用される場合、これは成分単位で適用され、結果は同じ次元のテンソルになります。 2つの引数 (pow(t,u), min(t,u) ...) を持つ関数の場合、2つの非スカラー引数が渡された場合、次元は同じでなければなりません。たとえば、 &#8220;max([1;2],[0;3])&#8221; は &#8220;[0;3]&#8221; を返します。</p>
</div>
<div class="section" id="user-defined-scalar-functions">
<h2>ユーザー定義のスカラー関数<a class="headerlink" href="#user-defined-scalar-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>すでに定義されているスカラー関数にスカラー関数を追加することは可能です。汎用構築は、1つまたは2つのパラメータを持つスカラー関数のみを考慮します。汎用構築にスカラー関数を追加するには、次のように呼び出します。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ga_define_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nb_args</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">der1</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">der2</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span>

<span class="n">ga_define_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">getfem</span><span class="o">::</span><span class="n">pscalar_func_onearg</span> <span class="n">f1</span><span class="p">,</span> <span class="n">der1</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span>

<span class="n">ga_define_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">getfem</span><span class="o">::</span><span class="n">pscalar_func_twoargs</span> <span class="n">f2</span><span class="p">,</span> <span class="n">der1</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">der2</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">name</span></tt> は定義される関数の名前で、 <tt class="docutils literal"><span class="pre">nb_args</span></tt> は1または2です。最初の呼び出しでは、<tt class="docutils literal"><span class="pre">expr</span></tt> は汎用的な弱形式言語で関数を記述する文字列です。最初の変数に <tt class="docutils literal"><span class="pre">t</span></tt> を、2番目の変数に <tt class="docutils literal"><span class="pre">u</span></tt> （ <tt class="docutils literal"><span class="pre">nb_args</span></tt> が2に等しい場合）を使います。たとえば、 <tt class="docutils literal"><span class="pre">sin(2*t)+sqr(t)</span></tt> は有効な式です。 <tt class="docutils literal"><span class="pre">ga_workspace</span></tt> オブジェクトで定義された定数やデータを参照することはできません。<tt class="docutils literal"><span class="pre">der1</span></tt> と <tt class="docutils literal"><span class="pre">der2</span></tt> は <tt class="docutils literal"><span class="pre">t</span></tt> と <tt class="docutils literal"><span class="pre">u</span></tt> に対する導関数の式です。これらはオプションです。それらが提供されていない場合、導関数が必要な場合には記号的な微分が用いられます。 <tt class="docutils literal"><span class="pre">der1</span></tt> と <tt class="docutils literal"><span class="pre">der2</span></tt> が関数名だけであると定義されている場合、その導関数が対応する関数です。第2の呼び出しでは、 <tt class="docutils literal"><span class="pre">f1</span></tt> は1つのスカラーパラメーターを持つスカラーC関数上のCポインターでなければならず、 <tt class="docutils literal"><span class="pre">f2</span></tt> は2つのスカラーパラメーターを持つスカラーC関数上のCポインターでなければなりません。</p>
<p>さらに、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">ga_function_exists</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>trueは <tt class="docutils literal"><span class="pre">name</span></tt> が既に定義されている関数である場合に返されます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ga_undefine_function</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>この関数は関数を再定義することができるように、既に定義済みの関数の定義を取り消します（関数が存在しない場合はアクションはありません）。</p>
</div>
<div class="section" id="derivatives-of-defined-scalar-functions">
<h2>定義されたスカラー関数の導関数<a class="headerlink" href="#derivatives-of-defined-scalar-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関数名に接頭辞 <tt class="docutils literal"><span class="pre">Derivative_</span></tt> を加えることで、定義された関数の導関数を直接参照することができます。たとえば、 <tt class="docutils literal"><span class="pre">Derivative_sin(t)</span></tt> は <tt class="docutils literal"><span class="pre">cos(t)</span></tt> に相当します。 <tt class="docutils literal"><span class="pre">pow(t,u)</span></tt> のような2つの引数の関数の場合、関数名の前に接頭辞 <tt class="docutils literal"><span class="pre">Derivative_2_</span></tt> を付けた2番目の引数に関して導関数を参照できます。</p>
</div>
<div class="section" id="binary-operations">
<h2>バイナリ演算<a class="headerlink" href="#binary-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>テンソル間の特定の数のバイナリ演算が利用できます。</p>
<blockquote>
<div><ul class="simple">
<li><p class="first"><tt class="docutils literal"><span class="pre">+</span></tt> と <tt class="docutils literal"><span class="pre">-</span></tt> は、スカラ、ベクトル、行列、またはテンソルの標準的な加減算です。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">*</span></tt> はスカラ、行列-ベクトル、行列-行列または（4次テンソル）-行列の乗法を表します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/</span></tt> はスカラーによる除算を表します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">.</span></tt> は、ベクトルのスカラー積を表します。より一般的には、ベクトルを持つ最後のインデックスまたは別のテンソルの最初のインデックスを持つテンソルの収縮を表します。 <tt class="docutils literal"><span class="pre">*</span></tt> と <tt class="docutils literal"><span class="pre">.</span></tt> は、行列ベクトルまたは行列と行列の乗算と等価であることに注意してください。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">:</span></tt> は Frobenius 行列の積、またはより一般的には、マトリックスを有する2つの最後のインデックスに関するテンソルの収縮を表します。 <tt class="docutils literal"><span class="pre">*</span></tt> と <tt class="docutils literal"><span class="pre">:</span></tt> は（4次テンソル）行列の乗算と等価であることに注意してください。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">.*</span></tt> は、2つのベクトル/行列/テンソルの成分ごとの乗算を表します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">./</span></tt> は、2つのベクトル/行列/テンソルの成分ごとの除算を表します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;</span></tt> はテンソル積を表します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Contract(A,</span> <span class="pre">i,</span> <span class="pre">B,</span> <span class="pre">j)</span></tt> は、Aのi番目のインデックスとBのj番目のインデックスに関するテンソルAとBの縮小を表します。最初のインデックスは1です。例えば <tt class="docutils literal"><span class="pre">Contract(V,1,W,1)</span></tt> は <tt class="docutils literal"><span class="pre">V</span></tt> と <tt class="docutils literal"><span class="pre">W</span></tt> の2つのベクトルの <tt class="docutils literal"><span class="pre">VW</span></tt> に相当します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Contract(A,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">B,</span> <span class="pre">k,</span> <span class="pre">l)</span></tt> はAのインデックスi、jとBのインデックスk、lに関してテンソルAとBの二重収縮を表します。例えば、 <tt class="docutils literal"><span class="pre">Contract(A,1,2,B,1,2)</span></tt> は <tt class="docutils literal"><span class="pre">A</span></tt> と <tt class="docutils literal"><span class="pre">B</span></tt> の2つの行列の <tt class="docutils literal"><span class="pre">A:B</span></tt> に相当します。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="unary-operators">
<h2>単項演算子<a class="headerlink" href="#unary-operators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p class="first"><tt class="docutils literal"><span class="pre">-</span></tt> シンプレックスマイナス演算子: 式の符号を変更します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">'</span></tt> はベクトルの行列またはラインビューの転置を表します。テンソル <tt class="docutils literal"><span class="pre">A</span></tt> は2より大きい次数であり、 <tt class="docutils literal"><span class="pre">A'</span></tt> は2つの第1指標の逆数を表示します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Contract(A,</span> <span class="pre">i,</span> <span class="pre">j)</span></tt> は、i番目とj番目のインデックスに対するテンソルAの収縮を表します。例えば、 <tt class="docutils literal"><span class="pre">Contract(A,</span> <span class="pre">1,</span> <span class="pre">2)</span></tt> は、 <tt class="docutils literal"><span class="pre">A</span></tt> の <tt class="docutils literal"><span class="pre">Trace(A)</span></tt> に相当します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Swap_indices(A,</span> <span class="pre">i,</span> <span class="pre">j)</span></tt> はインデックス番号iとjを交換します。たとえば、 <tt class="docutils literal"><span class="pre">Swap_indices(A,</span> <span class="pre">1,</span> <span class="pre">2)</span></tt> は行列 <tt class="docutils literal"><span class="pre">A</span></tt> の <tt class="docutils literal"><span class="pre">A'</span></tt> に相当します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Index_move_last(A,</span> <span class="pre">i)</span></tt> は、インデックス番号iを最後に移動させます。例えば、 <tt class="docutils literal"><span class="pre">A</span></tt> が4次テンソルであるとすれば、 <tt class="docutils literal"><span class="pre">Index_move_last(A,</span> <span class="pre">2)</span></tt> の結果はテンソル <img class="math" src="../_images/math/153978890f92cfdf03422ecccc6e19174f0fff44.png" alt="B_ {i_1i_3i_4i_2} = A_ {i_1i_2i_3i_4}" style="vertical-align: -5px"/> になります。行列の場合、 <tt class="docutils literal"><span class="pre">Index_move_last(A,</span> <span class="pre">1)</span></tt> は <tt class="docutils literal"><span class="pre">A'</span></tt> に相当します。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="parentheses">
<h2>括弧<a class="headerlink" href="#parentheses" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>括弧は、標準的な方法で操作の順序を変更するために使用できます。括弧が表示されていない場合、<tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">:</span></tt>, <tt class="docutils literal"><span class="pre">.</span></tt>, <tt class="docutils literal"><span class="pre">.*</span></tt>, <tt class="docutils literal"><span class="pre">./</span></tt>, <tt class="docutils literal"><span class="pre">&#64;</span></tt>  の通常優先順位が使用されます。 微分なしで、優先度が高いものは単項演算子 <tt class="docutils literal"><span class="pre">-</span></tt> と <tt class="docutils literal"><span class="pre">'</span></tt> に予約されています。</p>
</div>
<div class="section" id="explicit-vectors">
<h2>陽なベクトル<a class="headerlink" href="#explicit-vectors" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>弱形式言語は、表記 <tt class="docutils literal"><span class="pre">[a,b,c,d,e]</span></tt> 、すなわちコンマで区切られた任意の数の成分を持つ陽なベクトル（すなわち、1テンソル）を定義することが可能なセミコロン <tt class="docutils literal"><span class="pre">[a;b;c;d;e]</span></tt> も許されます）、ベクトル全体は右括弧で始まり左括弧で終わります。成分は、いくつかの数値定数、いくつかの有効な式、試行関数を含むことができます。後者の場合、ベクトルは試行関数に関して均質でなければなりません。これは、型 <tt class="docutils literal"><span class="pre">[Test_u;</span> <span class="pre">Test_v]</span></tt> は許されません。有効な例として、 <tt class="docutils literal"><span class="pre">u</span></tt> をスカラーフィールド変数とすると <tt class="docutils literal"><span class="pre">[5*Grad_Test_u(2),</span> <span class="pre">2*Grad_Test_u(1)]</span></tt> があります。また、オペレータ（転置）を使うと、式 <tt class="docutils literal"><span class="pre">[a,b,c,d,e]'</span></tt> は <tt class="docutils literal"><span class="pre">行ベクトル</span></tt> 、つまり1x5行列を表します。</p>
</div>
<div class="section" id="explicit-matrices">
<h2>陽な行列<a class="headerlink" href="#explicit-matrices" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>陽なベクトルと同様に、 <tt class="docutils literal"><span class="pre">[[a,b],[c,d]]</span></tt> という表記で陽な行列（すなわち、2次テンソル）を定義することができます。つまり、カンマで区切られた任意の数の列ベクトル（セミコロンで区切られた行の構文 <tt class="docutils literal"><span class="pre">[a、c;</span> <span class="pre">b、d]</span></tt> も許可されます）。例えば、 <tt class="docutils literal"><span class="pre">[[11,21]、[12,22]、[13,23]]</span></tt> と <tt class="docutils literal"><span class="pre">[[11,12,13;21,22,23]</span></tt> はどちらも同じ2x3行列を表します。成分は、いくつかの数値定数、いくつかの有効な式、試行関数を含むことができます。</p>
</div>
<div class="section" id="explicit-tensors">
<h2>陽なテンソル<a class="headerlink" href="#explicit-tensors" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>入れ子の形式では、任意の次数の陽なテンソルが許可されます。 <tt class="docutils literal"><span class="pre">n</span></tt> 次のテンソルは、等次元の <tt class="docutils literal"><span class="pre">n-1</span></tt> 次テンソルを継承して書かれ、コンマで区切られています。たとえば、 <tt class="docutils literal"><span class="pre">[[[[1,2,3],[1,2,3]],[[1,2,3],[1,2,3]]],[[[1,2,3],[1,2,3]],[[1,2,3],[1,2,3]]]]</span></tt> は4次のテンソルです。もう一つの形式は、構文 <tt class="docutils literal"><span class="pre">Reshape([1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3],</span> <span class="pre">3,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2)</span></tt> であり、成分はFortranの次数で指定する必要があります。</p>
</div>
<div class="section" id="access-to-tensor-components">
<h2>テンソル成分へのアクセス<a class="headerlink" href="#access-to-tensor-components" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル/行列/テンソルの成分へのアクセスは、左括弧、成分のリスト、右括弧の項をたどることによって行うことができます。たとえば、 <tt class="docutils literal"><span class="pre">[1,1,2](3)</span></tt> は正しく、期待通りに <tt class="docutils literal"><span class="pre">2</span></tt> を返します。インデックスは1で始まると仮定されていることに注意してください（C++やPythonインタフェースでも）。 <tt class="docutils literal"><span class="pre">[1,1;</span> <span class="pre">2,3](2,2)</span></tt> と <tt class="docutils literal"><span class="pre">Grad_u(2,2)</span></tt> という表現は、 <tt class="docutils literal"><span class="pre">u</span></tt> がベクトル値の宣言された変数であれば正しいです。構成要素は、一定の計算の結果であり得ることに留意してください。例えば、 <tt class="docutils literal"><span class="pre">[1,1;2,3](1+1,a)</span></tt> は <tt class="docutils literal"><span class="pre">a</span></tt> が宣言された定数ですが、変数として宣言されていない場合は正しいです。コロンはMatlabのようなシンタックスのインデックスの値を置き換えて、例えば行列の行や列にアクセスすることができます。<tt class="docutils literal"><span class="pre">[1,1;</span> <span class="pre">2,3](1,:)</span></tt> は行列 <tt class="docutils literal"><span class="pre">[1,1;2,3]</span></tt> の最初の行を示します。また、4次のテンソルで使用することもできます。</p>
</div>
<div class="section" id="constant-expressions">
<h2>定数式<a class="headerlink" href="#constant-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p class="first">標準表記の浮動小数点数（例えば、 <tt class="docutils literal"><span class="pre">3</span></tt> 、 <tt class="docutils literal"><span class="pre">1.456</span></tt> 、 <tt class="docutils literal"><span class="pre">1E-6</span></tt> ）</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">pi</span></tt>: 定数 Pi 。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">meshdim</span></tt>: 現在のメッシュの次元（すなわち、幾何学的節点のサイズ）</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">timestep</span></tt>: この構築文字列が評価されるmodelのメイン時間ステップ（<tt class="docutils literal"><span class="pre">model.set_time_step(dt)</span></tt> で定義されます）。純粋な作業領域では実行しないでください。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Id(n)</span></tt>: <img class="math" src="../_images/math/93f761f7fc79f2bec21a2f31c896840d6f36cdc0.png" alt="n\times n" style="vertical-align: 0px"/> サイズの単位行列。 <cite>n</cite> は整数式でなければなりません。例えば、 <tt class="docutils literal"><span class="pre">Id(meshdim)</span></tt> が許可されます。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">qdim(u)</span></tt>: 変数 <tt class="docutils literal"><span class="pre">u</span></tt> の全次元（すなわち、固定サイズ変数のサイズとFEM変数のベクトル/テンソルフィールドの合計サイズ）</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">qdims(u)</span></tt>: 変数 <tt class="docutils literal"><span class="pre">u</span></tt> のサイズ（すなわち、固定サイズ変数のサイズとFEM変数のベクトル/テンソルフィールドの次元のベクトル）</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="special-expressions-linked-to-the-current-position">
<h2>現在の位置にリンクされた特殊な表現<a class="headerlink" href="#special-expressions-linked-to-the-current-position" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p class="first"><tt class="docutils literal"><span class="pre">X(i)</span></tt> はi番目の成分であり、 <tt class="docutils literal"><span class="pre">X</span></tt> は実要素上の現在の座標（すなわち、式が評価される現在のGauss点のメッシュ上の位置）です。例えば、 <tt class="docutils literal"><span class="pre">sin(X(1)+X(2))</span></tt> は2次元以上のメッシュ上で有効な式です。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Normal</span></tt> は、境界の積分を行う際の境界の外向きの単位法線ベクトルです。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">element_size</span></tt> は、（ getfem::convex_radius_estimate を使って）現在の要素の直径の推定値を返します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">element_K</span></tt> は、参照（親）要素からの幾何学変換の勾配（ <a class="reference internal" href="../project/femdesc.html#dp-transgeo"><em>幾何学的変換</em></a> を参照）を与えます。メッシュに混合次元の要素が含まれていない場合にのみ使用できます。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">element_B</span></tt> は、参照（親）要素からの幾何学変換の勾配の擬似逆行列の転置を与えます（ <a class="reference internal" href="../project/femdesc.html#dp-transgeo"><em>幾何学的変換</em></a> を参照）。メッシュに混合次元の要素が含まれていない場合にのみ使用できます。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="print-command">
<h2>プリントコマンド<a class="headerlink" href="#print-command" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">Print(a)</span></tt> コマンドはデバッグ目的のためにテンソル <tt class="docutils literal"><span class="pre">a</span></tt> を出力し、それをそのまま渡します。たとえば、 <tt class="docutils literal"><span class="pre">Grad_u.Print(Grad_Test_u)</span></tt> は <tt class="docutils literal"><span class="pre">Grad_u.Grad_Test_u</span></tt> と同じ効果を持ちますが、各要素の各Gauss積分点に対してテンソル <tt class="docutils literal"><span class="pre">Grad_Test_u</span></tt> を出力します。定数項は、構築の最初に1回だけプリントされることに注意してください。項自体の代わりに項の導関数をプリントするように表現できることにも留意してください。</p>
</div>
<div class="section" id="reshape-a-tensor">
<h2>テンソルを変形する<a class="headerlink" href="#reshape-a-tensor" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>コマンド <tt class="docutils literal"><span class="pre">Reshape(t,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">...)</span></tt> はテンソル <tt class="docutils literal"><span class="pre">t</span></tt> （式でもよい）を再形成します。唯一の制約は、成分の数に互換性が必要なことです。例えば、  <tt class="docutils literal"><span class="pre">Reshape(Grad_u,</span> <span class="pre">1,</span> <span class="pre">meshdim)</span></tt> はスカラー変数の <tt class="docutils literal"><span class="pre">Grad_u'</span></tt> に相当します。成分次数は変更されず、 Blas/Lapack との互換性のためにFortranの次数で古典的に格納されることに注意してください。</p>
</div>
<div class="section" id="trace-deviator-sym-and-skew-operators">
<h2>Trace, Deviator, Sym と Skew 演算子<a class="headerlink" href="#trace-deviator-sym-and-skew-operators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Trace, Deviator, Sym および Skew 演算子は、正方行列に作用する線形演算子です。</p>
<blockquote>
<div><ul class="simple">
<li><p class="first"><tt class="docutils literal"><span class="pre">Trace(m)</span></tt> は正方行列 <tt class="docutils literal"><span class="pre">m</span></tt> のTrace（対角成分の合計）を返します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Deviator(m)</span></tt> は正方行列 <tt class="docutils literal"><span class="pre">m</span></tt> の偏差を与えます。 これは <tt class="docutils literal"><span class="pre">m-Trace(m)*Id(m_dim)/m_dim</span></tt> に相当します。ここで <tt class="docutils literal"><span class="pre">m_dim</span></tt> は <tt class="docutils literal"><span class="pre">m</span></tt> の次元です。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Sym(m)</span></tt> は正方行列 <tt class="docutils literal"><span class="pre">m</span></tt> の対称部分、すなわち <tt class="docutils literal"><span class="pre">(m</span> <span class="pre">+</span> <span class="pre">m')/2</span></tt> を与えます。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Skew(m)</span></tt> は、正方行列のSkew-対称部分、 <tt class="docutils literal"><span class="pre">(m</span> <span class="pre">-</span> <span class="pre">m')/2</span></tt> を返します。</p>
</li>
</ul>
</div></blockquote>
<p>4つの演算子を試行関数に適用することができます。これは、例えば <tt class="docutils literal"><span class="pre">Grad_u</span></tt> が正方行列（ <tt class="docutils literal"><span class="pre">u</span></tt> と同じ次元のベクトルフィールド）であるとき、 <tt class="docutils literal"><span class="pre">Trace(Grad_u)</span></tt> と <tt class="docutils literal"><span class="pre">Trace(Grad_Test_u)</span></tt> は有効であることを意味します。(すなわち、 <tt class="docutils literal"><span class="pre">u</span></tt> と次元として同じ次元のベクトルフィールドです。）。</p>
</div>
<div class="section" id="nonlinear-operators">
<h2>非線形演算子<a class="headerlink" href="#nonlinear-operators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>弱形式言語は、あらかじめ定義された非線形演算子を提供します。各非線形演算子は、その第1および第2導関数と共に利用可能です。非線形演算子は、式にいくつかの試行関数が含まれていない限り、適用できます。</p>
<blockquote>
<div><ul class="simple">
<li><p class="first">ベクトルまたは行列である <tt class="docutils literal"><span class="pre">v</span></tt> に対して <tt class="docutils literal"><span class="pre">Norm(v)</span></tt> を実行すると、ベクトルのユークリッドのノルムまたは Frobenius 行列のノルムが与えられます。</p>
</li>
<li><p class="first">ベクトルまたは行列のユークリッドのノルムの二乗は、 Frobenius 行列のノルムベクトルの場合、これは <tt class="docutils literal"><span class="pre">v.v</span></tt> に相当し、行列は <tt class="docutils literal"><span class="pre">m:m</span></tt> に相当します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">v</span></tt> に対して <tt class="docutils literal"><span class="pre">Normalized(v)</span></tt> は <tt class="docutils literal"><span class="pre">v</span></tt> をユークリッド（ベクトルの場合）または Frobenius  （行列の場合）ノルムで割られます。 <tt class="docutils literal"><span class="pre">v</span></tt> が0に近いときの問題を避けるため、 <tt class="docutils literal"><span class="pre">Normalized_reg(v,</span> <span class="pre">1E-25)</span></tt> として実装されています。注意して使用してください。 <tt class="docutils literal"><span class="pre">Normalized(v)*Norm(v)</span></tt> 起源の導関数は間違っています（今後削除されます）、 <tt class="docutils literal"><span class="pre">v</span></tt> の導関数とは非常に異なると考えてください。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">v</span></tt> の <tt class="docutils literal"><span class="pre">Normalized_reg(v,</span> <span class="pre">eps)</span></tt> ベクトルまたは行列は``Normalized(v)`` : <tt class="docutils literal"><span class="pre">v/sqrt(|v|*|v|+eps*eps)</span></tt> の正規化されたバージョンを与えます。</p>
</li>
<li><p class="first">ベクトルまたは行列 <tt class="docutils literal"><span class="pre">v</span></tt> とスカラーの <tt class="docutils literal"><span class="pre">r</span></tt> の <tt class="docutils literal"><span class="pre">Ball_projection(v,</span> <span class="pre">r)</span></tt> は、原点を中心にした半径 <tt class="docutils literal"><span class="pre">r</span></tt> のボールに <tt class="docutils literal"><span class="pre">v</span></tt> の投影を与えます。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Det(m)</span></tt> は正方行列 <tt class="docutils literal"><span class="pre">m</span></tt> の行列式を与えます。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Inv(m)</span></tt> は正方行列 <tt class="docutils literal"><span class="pre">m</span></tt> の逆行列を返します。2次導関数は、6次テンソルであるため利用できません。つまり、ポテンシャルエネルギーの記述には <tt class="docutils literal"><span class="pre">Inv(m)</span></tt> は使用できません。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Expm(m)</span></tt> は正方行列 <tt class="docutils literal"><span class="pre">m</span></tt> の指数を与えます。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Logm(m)</span></tt> は正方行列 <a href="#id1"><span class="problematic" id="id2">``</span></a>m``の対数を返します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Matrix_I2(m)</span></tt> は <tt class="docutils literal"><span class="pre">(sqr(Trace(m))</span> <span class="pre">-</span> <span class="pre">Trace(m*m))/2</span></tt> で定義される正方行列 <tt class="docutils literal"><span class="pre">m</span></tt> の第2の不変量を返します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Matrix_J1(m)</span></tt> は、  <tt class="docutils literal"><span class="pre">Trace(m)pow(Det(m),-1/3)</span></tt> で定義された正方行列の最初の不変量を修正したものです。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Matrix_J2(m)</span></tt> は  <tt class="docutils literal"><span class="pre">Matrix_I2(m)*pow(Det(m),-2/3)</span></tt> で定義された正方行列の修正された最初の不変量を返します。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="macro-definition">
<span id="ud-gasm-high-macros"></span><h2>マクロ定義<a class="headerlink" href="#macro-definition" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>弱形式言語を使用すると、modelまたは ga_workspace オブジェクトであらかじめ定義されているか、構築文字列の先頭に直接定義されているマクロを使用できます。ga_workspace またはmodelオブジェクトへの定義は次のように行われます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">add_macro</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>または次の通りです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">model</span><span class="p">.</span><span class="n">add_macro</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>マクロの構築文字列への定義は、正規表現の前に次の構文でセミコロンで区切られて挿入されます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Def name:=expr; regular_expression&quot;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">name</span></tt> はマクロ名であり、弱形式言語で使用され、マクロのパラメータも含みます。 <tt class="docutils literal"><span class="pre">expr</span></tt> は弱形式言語の有効な式です（それ自体がいくつかのマクロ定義を含むかもしれません）。たとえば、パラメータを持たない有効なマクロは次の通りです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">model</span><span class="p">.</span><span class="n">add_macro</span><span class="p">(</span><span class="s">&quot;my_transformation&quot;</span><span class="p">,</span> <span class="s">&quot;[cos(alpha)*X(1);sin(alpha)*X(2)]&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">alpha</span></tt> は有効な宣言された変数またはデータでなければなりません。 2つのパラメータを持つ有効なマクロは、例えば次の通りです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">model</span><span class="p">.</span><span class="n">add_macro</span><span class="p">(</span><span class="s">&quot;ps(a,b)&quot;</span><span class="p">,</span> <span class="s">&quot;a.b&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>次の構築文字列は有効です（ <tt class="docutils literal"><span class="pre">u</span></tt> が有効な変数である場合）。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Def ps(a,b):=a.b; ps(Grad_u, Grad_Test_u)&quot;</span>
</pre></div>
</div>
<p>パラメータは <tt class="docutils literal"><span class="pre">Grad_</span></tt> 、 <tt class="docutils literal"><span class="pre">Hess_</span></tt> 、 <tt class="docutils literal"><span class="pre">Test_</span></tt> 、 <tt class="docutils literal"><span class="pre">Test2_</span></tt> の接頭辞の後に固定することができ、次の構築文字列が有効です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Def psgrad(a,b):=Grad_a.Grad_b; psgrad(u, Test_u)&quot;</span>
</pre></div>
</div>
<p>または2つのマクロの組み込みも可能です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;Def ps(a,b):=a.b; Def psgrad(a,b):=ps(Grad_a,Grad_b); psgrad(u, Test_u)&quot;</span>
</pre></div>
</div>
<p>マクロは、次のようにga_workspaceオブジェクトまたはmodelオブジェクトから削除できます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">del_macro</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="n">model</span><span class="p">.</span><span class="n">del_macro</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>構築文字列の先頭に定義されたマクロはその構築文字列でのみ定義され、後で model または ga_workspace オブジェクトに追加することなく使用することはできないことに注意してください。</p>
<p>このマクロは字句解析フェーズでインライン展開されます。コンパイル段階では、繰り返し式は自動的に分解され、1回だけ計算されます。</p>
</div>
<div class="section" id="explicit-differentiation">
<h2>陽な微分<a class="headerlink" href="#explicit-differentiation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>workspaceオブジェクトは、より低い次数の微分を自動的に微分します。しかしながら、変数に対して式を陽に微分することもできます。 注目すべきは、自動微分はmodel/workspaceの宣言されたすべての変数に関して微分を実行しますが、これは例えばポテンシャルエネルギーを使用する場合に必ずしも期待される挙動ではありません。構文は次の通りです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Diff</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
</pre></div>
</div>
<p>例えば、次の式の場合</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Diff</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>結果は次の通りです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">Test_u</span><span class="p">)</span>
</pre></div>
</div>
<p>そのため次のようにします。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="nl">Grad_u:</span><span class="n">Grad_test_u</span> <span class="o">+</span> <span class="n">Diff</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>これは有効な式です。方向を指定するために <tt class="docutils literal"><span class="pre">Diff</span></tt> コマンドに3番目の引数を追加することができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Diff</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
</pre></div>
</div>
<p>その場合、 <tt class="docutils literal"><span class="pre">Test_variable</span></tt> を <tt class="docutils literal"><span class="pre">variable</span></tt> と同じ次元である式 <tt class="docutils literal"><span class="pre">direction</span></tt> で置き換えます。 <tt class="docutils literal"><span class="pre">direction</span></tt> 方向の <tt class="docutils literal"><span class="pre">variable</span></tt> に対して <tt class="docutils literal"><span class="pre">expression</span></tt> の導関数を計算します。例えば。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Diff</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>結果は次の通りです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">v</span></tt> は <tt class="docutils literal"><span class="pre">u</span></tt> と同じ次元の有効な式です。</p>
</div>
<div class="section" id="explicit-gradient">
<h2>陽な勾配<a class="headerlink" href="#explicit-gradient" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>次の関数を使って式の勾配の記号計算をすることができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Grad</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
</pre></div>
</div>
<p>これは可能な限り計算されます。制限として、 <em>GetFEM++</em> は形状関数の2階微分に限定され、非線形演算子は1次微分と2次微分のみを与えると考えられています。</p>
<p>もちろん、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>は次と等価です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Grad_u</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">u</span></tt> は変数です。</p>
</div>
<div class="section" id="interpolate-transformations">
<span id="ud-gasm-high-transf"></span><h2>補間変換<a class="headerlink" href="#interpolate-transformations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">Interpolate</span></tt> 演算は、メッシュの異なる部分に定義された量または異なるメッシュに定義された量の間の積分を計算することを可能にします。それはMortar行列を計算するか、または周期的な条件を考慮に入れることができる強力な演算です。しかしながら、これは無視できない計算コストを有するかもしれない補間に基づいていることを覚えておいてください。</p>
<p>この機能を使用するために、ユーザはまず、現在の積分ポイントと同じメッシュまたは別のメッシュ上にあるポイントとの間のマップを記述する補間変換を workspace または model オブジェクトに宣言する必要があります。</p>
<p>異なる種類の変換を記述するためにいくつかの種類の変換が実装されています。以下で説明する最初のものは、式によって記述される変換です。2番目はレイトレーシング接触検出に相当します（ <a class="reference internal" href="model_contact_friction_large_sliding.html#ud-model-contact-friction-raytrace-inter-trans"><em>レイトレーシング補間変換</em></a> を参照）。次のセクションでは、他の変換（隣接要素と要素の外挿）について説明します。</p>
<p>式で定義された変換は、次のコマンドにより workspace またはmodelに追加できます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_interpolate_transformation_from_expression</span>
  <span class="p">(</span><span class="n">workspace</span><span class="p">,</span> <span class="n">transname</span><span class="p">,</span> <span class="n">source_mesh</span><span class="p">,</span> <span class="n">target_mesh</span><span class="p">,</span> <span class="n">expr</span><span class="p">);</span>
</pre></div>
</div>
<p>または次の通りです。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_interpolate_transformation_from_expression</span>
  <span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">transname</span><span class="p">,</span> <span class="n">source_mesh</span><span class="p">,</span> <span class="n">target_mesh</span><span class="p">,</span> <span class="n">expr</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">workspace</span></tt> はworkspaceオブジェクト、 <tt class="docutils literal"><span class="pre">model</span></tt> はmodelオブジェクト、 <tt class="docutils literal"><span class="pre">transname</span></tt> は変換に与えられた名前、 <tt class="docutils literal"><span class="pre">source_mesh</span></tt> は積分が行われるメッシュ、 <tt class="docutils literal"><span class="pre">target_mesh</span></tt> 補間が実行されるメッシュで <tt class="docutils literal"><span class="pre">expr</span></tt> は、workspace/modelの変数への参照を含む高水準の汎用的な弱形式言語の正規表現です。</p>
<p>例えば、次の式は、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_interpolate_transformation_from_expression</span>
  <span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;my_transformation&quot;</span><span class="p">,</span> <span class="n">my_mesh</span><span class="p">,</span> <span class="n">my_mesh</span><span class="p">,</span> <span class="s">&quot;X-[1;0]&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>現在の位置にある式を最初の座標に対して-1のシフトで積分することができます。この単純な種類の変換を使用して、周期的な条件を規定することができます。</p>
<p>もちろん、もっと複雑な表現を使うかもしれません。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_interpolate_transformation_from_expression</span>
  <span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;my_transformation&quot;</span><span class="p">,</span> <span class="n">my_mesh</span><span class="p">,</span> <span class="n">my_second_mesh</span><span class="p">,</span> <span class="s">&quot;[X[1]cos(X[2]); X[1]sin(X[2])]&quot;</span><span class="p">);</span>

<span class="n">add_interpolate_transformation_from_expression</span>
  <span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;my_transformation&quot;</span><span class="p">,</span> <span class="n">my_mesh</span><span class="p">,</span> <span class="n">my_mesh</span><span class="p">,</span> <span class="s">&quot;X+u&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>ここで <tt class="docutils literal"><span class="pre">u</span></tt> はworkspace/modelのベクトル変数です。</p>
<p>workspace/modelで変換が定義されると、変数または試行関数、これらの式の1つのために境界への位置または単位法線ベクトルを補間できます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Interpolate</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Grad_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Div_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Hess_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Test_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Grad_Test_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Div_Test_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Hess_Test_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <tt class="docutils literal"><span class="pre">u</span></tt> は補間される変数の名前です。</p>
<p>例えば、乗算器 <tt class="docutils literal"><span class="pre">lambda</span></tt> によって、変数 <tt class="docutils literal"><span class="pre">u</span></tt> とその補間（例えば、周期的境界条件を規定するため）との等価を規定する構築式は、次のように書くことができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">(</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">my_transformation</span><span class="p">)</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">lambda</span>
</pre></div>
</div>
<p>( <tt class="file docutils literal"><span class="pre">interface/tests/matlab</span></tt> 内の <tt class="file docutils literal"><span class="pre">demo_periodic_laplacian.m</span></tt> を参照してください。)</p>
<p>場合によっては、変換された点がターゲットメッシュの外側にある場合、点の補間が失敗することがあります。両方とも、このケースを処理し、変換が他のいくつかの場合を微分できるようにするために（両方とも、剛体とRaytracing_interpolate_transformationの変形可能なものとの間の差異については。 <a class="reference internal" href="model_contact_friction_large_sliding.html#ud-model-contact-friction-raytrace-inter-trans"><em>レイトレーシング補間変換</em></a> を参照）、変換は整数識別子が弱形式言語に返されます。この識別子の値0は、ターゲットメッシュ上の対応する位置が見つからなかったことを意味します。 1の値は、対応する点が見つかったことを意味します。この識別子は、弱形式言語の次の特別なコマンドにより使用できます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Interpolate_filter</span><span class="p">(</span><span class="n">transname</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">transname</span></tt> は変換の名前、 <tt class="docutils literal"><span class="pre">expr</span></tt> は評価される式、<tt class="docutils literal"><span class="pre">i</span></tt> は式が計算されるべきかを返す整数識別子です。 <tt class="docutils literal"><span class="pre">i</span></tt> は省略することができ、この場合、式は非ゼロの識別情報（すなわち、対応する点が見つかったとき）について評価されることに留意してください。例えば、変数``u`` とその補間との等価を規定する以前の構築式は、次のように書くことができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Interpolate_filter</span><span class="p">(</span><span class="n">transmane</span><span class="p">,</span> <span class="n">Interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">my_transformation</span><span class="p">)</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">lambda</span><span class="p">)</span>
<span class="o">+</span> <span class="n">Interpolate_filter</span><span class="p">(</span><span class="n">transmane</span><span class="p">,</span> <span class="n">lambda</span><span class="o">*</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>その場合、等式は、変換が成功する領域の部分でのみ規定され、他の部分では、乗数は消滅するように強制されます。</p>
<p><strong>注意</strong> : 変換でいくつかの変数が使用される場合、接触モデルの計算でこれらの依存性が考慮されていると考える必要があります。しかし、使用される変数に関する変換の2次導関数は実装されていません。従って、このような変換は、2回微分することができないので、電位の定義には使用できません。</p>
</div>
<div class="section" id="element-extrapolation-transformation">
<h2>要素外挿変換<a class="headerlink" href="#element-extrapolation-transformation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>別の要素（一般的に隣接要素）に関してある量の外挿による評価を可能にするために、特定の変換（前の節を参照）が定義されます。点の位置は変わらないので、厳密には変換ではありませんが、評価は試行関数を外挿する別の要素に対して行われます。この変換は、現実の領域との十分に大きな交差を有する隣接要素のいくつかの量を、現在の要素が小さい場合にそれらを評価するよりも外挿することがより確実である仮想領域法（切断要素を有する）において、このような実領域との交差変換をmodelまたはworkspaceに追加するには次の関数を使用します。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_element_extrapolation_transformation</span>
<span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">transname</span><span class="p">,</span> <span class="n">my_mesh</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">size_type</span><span class="p">,</span> <span class="n">size_type</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">elt_corr</span><span class="p">);</span>

<span class="n">add_element_extrapolation_transformation</span>
<span class="p">(</span><span class="n">workspace</span><span class="p">,</span> <span class="n">transname</span><span class="p">,</span> <span class="n">my_mesh</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">size_type</span><span class="p">,</span> <span class="n">size_type</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">elt_corr</span><span class="p">);</span>
</pre></div>
</div>
<p>マップelt_corrには、変換が適用される要素と、補外が行われる必要があります。それぞれの要素との間の対応関係が含まれている必要があります。マップにリストされていない要素では、変換は適用されず、評価は現在の要素に対して正常に実行されます。</p>
<p>以下の関数は、以前に追加された要素補間変換の要素対応を変更することを可能にします。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">set_element_extrapolation_correspondance</span>
<span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">transname</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">size_type</span><span class="p">,</span> <span class="n">size_type</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">elt_corr</span><span class="p">);</span>

<span class="n">set_element_extrapolation_correspondance</span>
<span class="p">(</span><span class="n">workspace</span><span class="p">,</span> <span class="n">transname</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">size_type</span><span class="p">,</span> <span class="n">size_type</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">elt_corr</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="evaluating-discontinuities-across-inter-element-edges-faces">
<span id="ud-gasm-high-inter-elt-disc"></span><h2>要素間エッジ/面間の不連続性の評価します。<a class="headerlink" href="#evaluating-discontinuities-across-inter-element-edges-faces" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">neighbour_elt</span></tt> と呼ばれる特定の補間変換（前のセクションを参照）は、デフォルトですべてのmodelで定義されています。この変換は、メッシュの内部エッジ/面、すなわち少なくとも2つの要素によって共有される要素面で計算が行われる場合にのみ使用できます。これは、要素間の面で変数の不連続ジャンプを計算することを目的としています。不連続Galerkinと内部ペナルティ法、ゴーストペナルティ項または事後推定を実装するのに特に適しています。表現は、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Interpolate</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Grad_u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Div_u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Hess_u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Test_u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Grad_Test_u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Div_Test_u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">Hess_Test_u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
</pre></div>
</div>
<p>（他の補間変換の場合と同様に）現在の点ではなく隣接要素上のフィールドを計算することができます。もちろん、 <tt class="docutils literal"><span class="pre">Interpolate(X,</span> <span class="pre">neighbour_elt)</span></tt> は <tt class="docutils literal"><span class="pre">X</span></tt> と同じ結果を返すのでそれほど特別なものではありません。同様に、ほとんどの場合、 <tt class="docutils literal"><span class="pre">Interpolate(X,</span> <span class="pre">neighbour_elt)</span></tt> は、関心のある3Dメッシュの2Dシェル要素を除いて、 <tt class="docutils literal"><span class="pre">Normal</span></tt> の反対側を返します。</p>
<p>変数 <tt class="docutils literal"><span class="pre">u</span></tt> のジャンプは、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">u</span><span class="o">-</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">)</span>
</pre></div>
</div>
<p>ジャンプのペナルティ・タームを書くことができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">Test_u</span><span class="o">-</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">Test_u</span><span class="p">,</span> <span class="n">neighbour_elt</span><span class="p">))</span>
</pre></div>
</div>
<p>メッシュのすべての内部面の集合を表す領域は、次の関数により与えられます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">mr_internal_face</span> <span class="o">=</span> <span class="n">inner_faces_of_mesh</span><span class="p">(</span><span class="n">my_mesh</span><span class="p">,</span> <span class="n">mr</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <tt class="docutils literal"><span class="pre">mr</span></tt> はオプションのメッシュ領域です。<tt class="docutils literal"><span class="pre">mr</span></tt> が指定されていれば、この領域に関して内部の面だけが返されます。重要な点は、各面が1回だけ表され、2つの隣接要素の間で任意に選択されることです。</p>
<p>使用例は <tt class="file docutils literal"><span class="pre">interface/tests/python/demo_laplacian_DG.py</span></tt> や <tt class="file docutils literal"><span class="pre">interface/tests/matlab/demo_laplacian_DG.m</span></tt> を参照してください。</p>
<p>他の補間変換と比較すると、この変換はより最適化され、有限要素変換および幾何変換前処理で恩恵があります。</p>
</div>
<div class="section" id="double-domain-integrals-or-terms-convolution-kernel-exchange-integrals">
<span id="ud-gasm-high-secondary-dom"></span><h2>2重領域の積分または項（畳み込み - カーネル - 交換積分）<a class="headerlink" href="#double-domain-integrals-or-terms-convolution-kernel-exchange-integrals" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いくつかの非常に特殊な場合には、2つの領域の直積、すなわち例えば2重積分の積分を計算することに着目する必要があります。</p>
<div class="math">
<p><img src="../_images/math/98881cf1ece1fc5d1785b255fd18f04e56b204ec.png" alt="\int_{\Omega_1}\int_{\Omega_2}k(x,y)u(x)v(y)dydx,"/></p>
</div><p>ここで <img class="math" src="../_images/math/2249dba2b9cc51538a37a6fb439f722dd96c2071.png" alt="k(x,y)" style="vertical-align: -4px"/> は与えられたカーネルです、 <img class="math" src="../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u" style="vertical-align: 0px"/> は <img class="math" src="../_images/math/25c056f01b2d920f07a2a9bee3a455aa739c218a.png" alt="\Omega_1" style="vertical-align: -4px"/> 上で定義された量で <img class="math" src="../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v" style="vertical-align: 0px"/> は <img class="math" src="../_images/math/1705dcf5b6ed693e2aaea2fda973ea0b976433db.png" alt="\Omega_2" style="vertical-align: -3px"/> 上で定義された量です、 <img class="math" src="../_images/math/25c056f01b2d920f07a2a9bee3a455aa739c218a.png" alt="\Omega_1" style="vertical-align: -4px"/> と <img class="math" src="../_images/math/1705dcf5b6ed693e2aaea2fda973ea0b976433db.png" alt="\Omega_2" style="vertical-align: -3px"/> は同じ領域にあります。これは、そのような積分を計算するか、または2つの異なる領域上に定義された2つの変数間の相互作用項を定義する際に着目する必要があります。</p>
<p>注意: 当然のことながら、この種の項は、通常完全に計算された剛性または接線行列に関連するため、細心の注意を払って使用する必要があります。</p>
<p><em>GetFEM++</em> の弱形式言語はそのような項を計算するためのメカニズムを与えます。まず、第2領域は、その積分法を使用してworkspace/model内で宣言されなければなりません。標準的な第2領域の追加は、次の2つの関数のうちの1つを使用して行うことができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_standard_secondary_domain</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">domain_name</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>

<span class="n">add_standard_secondary_domain</span><span class="p">(</span><span class="n">workspace</span><span class="p">,</span> <span class="n">domain_name</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">model</span></tt> または <tt class="docutils literal"><span class="pre">workspace</span></tt> は第2領域を宣言しなければならないmodelまたはworkspaceで、 <tt class="docutils literal"><span class="pre">domain_name</span></tt> はメッシュ領域と積分法とともにこの領域を識別する文字列です。積分法を <tt class="docutils literal"><span class="pre">mim</span></tt> 、メッシュ領域を <tt class="docutils literal"><span class="pre">region</span></tt> と呼びます。これらの標準的な第2領域では、第1領域の各要素について領域全体で積分が行われることに着目してください。第1領域の要素に関して必要な要素への積分を制限する特定の第2領域を実装することに着目してください。<em>GetFEM++</em> の中の構造体はこれ専用です。</p>
<p>第2領域が宣言されると、現在の領域と第2領域の直接的な生成物に弱形式言語をアセンブルし、 <tt class="docutils literal"><span class="pre">add_expression</span></tt> メソッドに次の関数を使用して、第2領域の名前を追加する必要があると指定できます。 <tt class="docutils literal"><span class="pre">add_linear_twodomain_term</span></tt> 、 <tt class="docutils literal"><span class="pre">add_nonlinear_twodomain_term</span></tt> または <tt class="docutils literal"><span class="pre">add_twodomain_source_term</span></tt> の関数となります。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">workspace</span><span class="p">.</span><span class="n">add_expression</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">derivative_order</span><span class="p">,</span> <span class="n">secondary_domain</span><span class="p">)</span>
<span class="n">add_twodomain_source_term</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">secondary_domain</span><span class="p">)</span>
<span class="n">add_linear_twodomain_term</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">secondary_domain</span><span class="p">)</span>
<span class="n">add_nonlinear_twodomain_term</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mim</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">secondary_domain</span><span class="p">)</span>
</pre></div>
</div>
<p>Python / Scilab / Matlabインタフェースを利用するには、 <tt class="docutils literal"><span class="pre">gf_asm</span></tt> コマンドと <tt class="docutils literal"><span class="pre">model</span></tt> オブジェクトに関するドキュメントを参照してください。</p>
<p>弱形式言語の表現中で、式により、境界への単位法線ベクトル、変数の現在の位置または値を参照することができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Secondary_domain</span><span class="p">(</span><span class="n">Normal</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">Grad_u</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">Div_u</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">Hess_u</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">Test_u</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">Grad_Test_u</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">Div_Test_u</span><span class="p">)</span>
<span class="n">Secondary_domain</span><span class="p">(</span><span class="n">Hess_Test_u</span><span class="p">)</span>
</pre></div>
</div>
<p>たとえば、</p>
<div class="math">
<p><img src="../_images/math/34ae582dcc2a5cae718ff83c68f40958c78c643b.png" alt="\int_{\Omega_1}\int_{\Omega_1}e^{-\|x-y\|}u(x)u(y)dydx,"/></p>
</div><p>は次の弱形式言語に対応します。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">exp</span><span class="p">(</span><span class="n">Norm</span><span class="p">(</span><span class="n">X</span><span class="o">-</span><span class="n">Secondary_domain</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">Secondary_domain</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="elementary-transformations">
<span id="ud-gasm-high-elem-trans"></span><h2>初等変換<a class="headerlink" href="#elementary-transformations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本変換は、要素水準で局所自由度に適用される要素に依存する可能性のある行列によって与えられる形状関数の線形変換です。基本変換の定義の例はファイル <tt class="file docutils literal"><span class="pre">src/getfem_linearized_plates.cc</span></tt> にあります。これは、例えば、MITC要素で使用されるような縮小を実行するために、より低い水準の要素上の有限要素の局所射影を定義することを目的とします。</p>
<p>変換が定義されると、model/workspaceに次のメソッドを追加することができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">model</span><span class="p">.</span><span class="n">add_elementary_transformation</span><span class="p">(</span><span class="n">transname</span><span class="p">,</span> <span class="n">pelementary_transformation</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <tt class="docutils literal"><span class="pre">pelementary_transformation</span></tt> は <tt class="docutils literal"><span class="pre">virtual_elementary_transformation</span></tt> から派生したオブジェクトへのポインタです。model/workspaceに追加されると、弱形式言語で次の式を使用することができます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Elementary_transformation</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Elementary_transformation</span><span class="p">(</span><span class="n">Grad_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Elementary_transformation</span><span class="p">(</span><span class="n">Div_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Elementary_transformation</span><span class="p">(</span><span class="n">Hess_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Elementary_transformation</span><span class="p">(</span><span class="n">Test_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Elementary_transformation</span><span class="p">(</span><span class="n">Grad_Test_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Elementary_transformation</span><span class="p">(</span><span class="n">Div_Test_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
<span class="n">Elementary_transformation</span><span class="p">(</span><span class="n">Hess_Test_u</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <tt class="docutils literal"><span class="pre">u</span></tt> はmodel/workspaceのFEM変数の1つです。現時点では、利用可能な基本変換は、（ <tt class="file docutils literal"><span class="pre">src/getfem/getfem_linearized_plates.h</span></tt> で定義されている）次の関数により追加できる2次元要素の回転RT0要素の投影です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_2D_rotated_RT0_projection</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">transname</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="xfem-discontinuity-evaluation-with-mesh-fem-level-set">
<span id="ud-gasm-high-xfem"></span><h2>Xfem不連続性評価（mesh_fem_level_setを使用）<a class="headerlink" href="#xfem-discontinuity-evaluation-with-mesh-fem-level-set" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><em>GetFEM++</em> 5.1.から。レベル集合（ fem_level_set または mesh_fem_level_set オブジェクトを使用）によって有限要素法を切断する場合、変数の不連続ジャンプ、または勾配または平均値のジャンプを組み込むのが面白いことがよくあります。そのために、弱形式言語は、 <tt class="docutils literal"><span class="pre">u</span></tt> のFEM変数を定義しています。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Xfem_plus</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">Xfem_plus</span><span class="p">(</span><span class="n">Grad_u</span><span class="p">)</span>
<span class="n">Xfem_plus</span><span class="p">(</span><span class="n">Div_u</span><span class="p">)</span>
<span class="n">Xfem_plus</span><span class="p">(</span><span class="n">Hess_u</span><span class="p">)</span>
<span class="n">Xfem_plus</span><span class="p">(</span><span class="n">Test_u</span><span class="p">)</span>
<span class="n">Xfem_plus</span><span class="p">(</span><span class="n">Test_Grad_u</span><span class="p">)</span>
<span class="n">Xfem_plus</span><span class="p">(</span><span class="n">Test_Div_u</span><span class="p">)</span>
<span class="n">Xfem_plus</span><span class="p">(</span><span class="n">Test_Hess_u</span><span class="p">)</span>

<span class="n">Xfem_minus</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">Xfem_minus</span><span class="p">(</span><span class="n">Grad_u</span><span class="p">)</span>
<span class="n">Xfem_minus</span><span class="p">(</span><span class="n">Div_u</span><span class="p">)</span>
<span class="n">Xfem_minus</span><span class="p">(</span><span class="n">Hess_u</span><span class="p">)</span>
<span class="n">Xfem_minus</span><span class="p">(</span><span class="n">Test_u</span><span class="p">)</span>
<span class="n">Xfem_minus</span><span class="p">(</span><span class="n">Test_Grad_u</span><span class="p">)</span>
<span class="n">Xfem_minus</span><span class="p">(</span><span class="n">Test_Div_u</span><span class="p">)</span>
<span class="n">Xfem_minus</span><span class="p">(</span><span class="n">Test_Hess_u</span><span class="p">)</span>
</pre></div>
</div>
<p>これは、連続性の2つのゾーンを分離する曲線/表面、すなわち、考慮されるレベル集合関数のゼロレベル集合（ <tt class="docutils literal"><span class="pre">mesh_im_level_set</span></tt> オブジェクトを使用する）で評価（積分）が行われる場合にのみ利用可能です。例えば、 <tt class="docutils literal"><span class="pre">u</span></tt> 変数のジャンプは次のようになります。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Xfem_plus</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">Xfem_minus</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>平均値は次のようになります。</p>
<div class="highlight-c++"><pre>(Xfem_plus(u)+Xfem_minus(u))/2

The value ``Xfem_plus(u)`` is the value of ``u`` on the side where the corresponding level-set function is positive and ``Xfem_minus(u)`` the value of ``u`` on the side where the level-set function is negative.

Additionally, note that, when integrating on a level-set with a ``mesh_im_level_set`` object, ``Normal`` stands for the normal unit vector to the level-set in the direction of the gradient of the level-set function.</pre>
</div>
</div>
<div class="section" id="storage-of-sub-expressions-in-a-getfem-im-data-object-during-assembly">
<h2>構築中の getfem::im_data オブジェクトへのサブ式の格納<a class="headerlink" href="#storage-of-sub-expressions-in-a-getfem-im-data-object-during-assembly" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>getfem::im_data オブジェクトに応じてベクトルに格納することができます。たとえば、この計算を別の構築で使用するために、構築計算の一部にすることができます。これは、同じ式を2回計算しないようにするための補間関数の代替方法です。</p>
<p>このような割り当てを構築に追加する方法は、 model または ga_workspace です。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">model</span><span class="p">.</span><span class="n">add_assembly_assignments</span><span class="p">(</span><span class="n">dataname</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">region</span> <span class="o">=</span> <span class="n">size_type</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                               <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">before</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>

<span class="n">workspace</span><span class="p">.</span><span class="n">add_assignment_expression</span><span class="p">(</span><span class="n">dataname</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span>
          <span class="n">region</span> <span class="o">=</span> <span class="n">mesh_region</span><span class="o">::</span><span class="n">all_convexes</span><span class="p">(),</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">before</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span>
</pre></div>
</div>
<p>構築時に評価される式 <cite>expr</cite> を追加し、im_data型でなければならないデータ <cite>dataname</cite> に代入します。 <cite>order</cite> は、この割り当てが行われなければならない構築の次数を表します（ポテンシャル（0）、弱形式（1）または接線のシステム（2）または次数ごと（-1））。 before = 1 の場合、代入は他の構築項の計算の前に実行されるため、データを構築の残りの部分で中間結果として使用することができます（データとしてはまだ考慮していることに注意してください、接線系の式の微分は行われません）。before = 0（デフォルト）の場合、構築の項の後に割り当てが行われます。</p>
<p>さらに、modelでは、次のメソッドがあります。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">model</span><span class="p">.</span><span class="n">clear_assembly_assignments</span><span class="p">()</span>
</pre></div>
</div>
<p>これにより、以前に追加された構築割り当てをすべてキャンセルすることができます。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <p class="logo"><a href="../index.html">
    <img class="logo" src="../_static/logo_getfem_small.png" alt="Logo"/>
  </a></p>
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">任意の項を計算する - 高水準の汎用的な構築手順 - 弱形式言語</a><ul>
<li><a class="reference internal" href="#differences-in-execution-time-between-high-and-low-level-generic-assembly">高水準と低水準の汎用構築間の実行時間の差</a></li>
<li><a class="reference internal" href="#overview-of-the-weak-form-language-syntax">弱形式言語構文の概要</a></li>
<li><a class="reference internal" href="#some-basic-examples">いくつかの基本的な例</a></li>
<li><a class="reference internal" href="#derivation-order-and-symbolic-differentiation">微分次数と記号による微分</a></li>
<li><a class="reference internal" href="#c-call-of-the-assembly">構築のためのC ++呼び出し</a></li>
<li><a class="reference internal" href="#c-assembly-examples">C ++構築の例</a></li>
<li><a class="reference internal" href="#script-languages-call-of-the-assembly">構築言語のスクリプト言語からの呼び出し</a></li>
<li><a class="reference internal" href="#the-tensors">テンソル</a></li>
<li><a class="reference internal" href="#the-variables">変数</a></li>
<li><a class="reference internal" href="#the-constants-or-data">定数またはデータ</a></li>
<li><a class="reference internal" href="#test-functions">試行関数</a></li>
<li><a class="reference internal" href="#gradient">勾配</a></li>
<li><a class="reference internal" href="#hessian">Hessian</a></li>
<li><a class="reference internal" href="#predefined-scalar-functions">定義済みのスカラー関数</a></li>
<li><a class="reference internal" href="#user-defined-scalar-functions">ユーザー定義のスカラー関数</a></li>
<li><a class="reference internal" href="#derivatives-of-defined-scalar-functions">定義されたスカラー関数の導関数</a></li>
<li><a class="reference internal" href="#binary-operations">バイナリ演算</a></li>
<li><a class="reference internal" href="#unary-operators">単項演算子</a></li>
<li><a class="reference internal" href="#parentheses">括弧</a></li>
<li><a class="reference internal" href="#explicit-vectors">陽なベクトル</a></li>
<li><a class="reference internal" href="#explicit-matrices">陽な行列</a></li>
<li><a class="reference internal" href="#explicit-tensors">陽なテンソル</a></li>
<li><a class="reference internal" href="#access-to-tensor-components">テンソル成分へのアクセス</a></li>
<li><a class="reference internal" href="#constant-expressions">定数式</a></li>
<li><a class="reference internal" href="#special-expressions-linked-to-the-current-position">現在の位置にリンクされた特殊な表現</a></li>
<li><a class="reference internal" href="#print-command">プリントコマンド</a></li>
<li><a class="reference internal" href="#reshape-a-tensor">テンソルを変形する</a></li>
<li><a class="reference internal" href="#trace-deviator-sym-and-skew-operators">Trace, Deviator, Sym と Skew 演算子</a></li>
<li><a class="reference internal" href="#nonlinear-operators">非線形演算子</a></li>
<li><a class="reference internal" href="#macro-definition">マクロ定義</a></li>
<li><a class="reference internal" href="#explicit-differentiation">陽な微分</a></li>
<li><a class="reference internal" href="#explicit-gradient">陽な勾配</a></li>
<li><a class="reference internal" href="#interpolate-transformations">補間変換</a></li>
<li><a class="reference internal" href="#element-extrapolation-transformation">要素外挿変換</a></li>
<li><a class="reference internal" href="#evaluating-discontinuities-across-inter-element-edges-faces">要素間エッジ/面間の不連続性の評価します。</a></li>
<li><a class="reference internal" href="#double-domain-integrals-or-terms-convolution-kernel-exchange-integrals">2重領域の積分または項（畳み込み - カーネル - 交換積分）</a></li>
<li><a class="reference internal" href="#elementary-transformations">初等変換</a></li>
<li><a class="reference internal" href="#xfem-discontinuity-evaluation-with-mesh-fem-level-set">Xfem不連続性評価（mesh_fem_level_setを使用）</a></li>
<li><a class="reference internal" href="#storage-of-sub-expressions-in-a-getfem-im-data-object-during-assembly">構築中の getfem::im_data オブジェクトへのサブ式の格納</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="rmesh.html"
                        title="前の章へ">メッシュの改善</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="gasm_low.html"
                        title="次の章へ">任意の項を計算する - 低水準の汎用的な構築手順</a></p>            <h3>Download</h3>
            <p><a href="../download.html">Download GetFEM++ </a></p>
	    <h3>Main documentations</h3>
	    <ul>
              
	      <li><a href="index.html">GetFEM++ User documentation</a></li>
              <li><a href="../python/index.html">Python Interface</a></li>
	      <li><a href="../matlab/index.html">Matlab Interface</a></li>
	      <li><a href="../scilab/index.html">Scilab Interface</a></li>
	      <li><a href="../gmm/index.html"> Gmm++</a></li>
	      <li><a href="../project/index.html"> GetFEM++ project</a></li>
            </ul>

            <h3>Other resources</h3>
            <ul>
              <li><a href="../screenshots/shots.html">Screenshots</a></li>
              <li><a href="../links.html">Related links</a></li>
	      <li><a href="https://savannah.nongnu.org/projects/getfem">Hosted by Savannah </a></li>
              
              
            </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="gasm_low.html" title="任意の項を計算する - 低水準の汎用的な構築手順"
             >次へ</a> |</li>
        <li class="right" >
          <a href="rmesh.html" title="メッシュの改善"
             >前へ</a> |</li>
        <li><a href="https://savannah.nongnu.org/projects/getfem" <img src="../_static/icon.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li></a>
        <li><a href="../index.html">GetFEM++</a> &raquo;</li>

          <li><a href="index.html" >ユーザドキュメント</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2004-2018 GetFEM++ project.
    </div>
  </body>
</html>