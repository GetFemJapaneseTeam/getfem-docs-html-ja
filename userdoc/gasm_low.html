<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>任意の項を計算する - 低水準の汎用的な構築手順 &mdash; GetFEM++</title>
    
    <link rel="stylesheet" href="../static/getfem.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="shortcut icon" href="../static/favicon.ico"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="GetFEM++" href="../index.html" />
    <link rel="up" title="ユーザドキュメント" href="index.html" />
    <link rel="next" title="いくつかの標準構築手順（低水準汎用構築）" href="asm.html" />
    <link rel="prev" title="任意の項を計算する - 高水準の汎用的な構築手順 - 弱形式言語" href="gasm_high.html" />
    <link rel="shortcut icon" type="image/png" href="../static/icon.png" />
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="asm.html" title="いくつかの標準構築手順（低水準汎用構築）"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="gasm_high.html" title="任意の項を計算する - 高水準の汎用的な構築手順 - 弱形式言語"
             accesskey="P">前へ</a> |</li>
        <li><a href="https://savannah.nongnu.org/projects/getfem" <img src="../static/icon.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li></a>
        <li><a href="../index.html">GetFEM++</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">ユーザドキュメント</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="compute-arbitrary-terms-low-level-generic-assembly-procedures">
<span id="ud-gasm-low"></span><span id="index-0"></span><h1>任意の項を計算する - 低水準の汎用的な構築手順<a class="headerlink" href="#compute-arbitrary-terms-low-level-generic-assembly-procedures" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>このセクションでは、 <em>GetFEM++</em> で実装された汎用構築手順の最初のバージョンを説明します。これにより、線形の場合に任意の行列の集合を容易に作成可能になります。非線形の場合、特殊な &#8220;non_linear_term&#8221; オブジェクトを実装する必要があります。これは複雑で、 <em>GetFEM++</em> という非常に低水準の内部ツールを使用する必要があります。高水準汎用構築は、この困難を回避するために開発されました（ <a class="reference internal" href="gasm_high.html#ud-gasm-high"><em>任意の項を計算する - 高水準の汎用的な構築手順 - 弱形式言語</em></a> 参照）。</p>
<p>ファイル <tt class="file docutils literal"><span class="pre">getfem/getfem_assembling.h</span></tt> で見ることができるように、以前の構築手順はすべて <tt class="docutils literal"><span class="pre">getfem::generic_assembly</span></tt> オブジェクトを使用しています。例えば、スカラーFEMのためのボリュームソース項の構築は、コードの以下の抜粋を用いて行われます。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">generic_assembly</span> <span class="n">assem</span><span class="p">;</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_im</span><span class="p">(</span><span class="n">mim</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_mf</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_mf</span><span class="p">(</span><span class="n">mfdata</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_data</span><span class="p">(</span><span class="n">F</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_vec</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;Z=data(#2);&quot;</span>
          <span class="s">&quot;V(#1)+=comp(Base(#1).Base(#2))(:,j).Z(j);&quot;</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">assembly</span><span class="p">();</span>
</pre></div>
</div>
<p>最初の命令はオブジェクトを宣言し、使用するデータを設定します。積分法を保持する <cite>mesh_im</cite> オブジェクト、2つの <cite>mesh_fem</cite> オブジェクト、入力データ <tt class="docutils literal"><span class="pre">F</span></tt> 、および宛先ベクトル <tt class="docutils literal"><span class="pre">B</span></tt> を含みます。</p>
<p>The input data is the vector <img class="math" src="../images/math/a055f405829e64a3b70253ab67cb45ed6ed5bb29.png" alt="F" style="vertical-align: 0px"/>, defined on <tt class="docutils literal"><span class="pre">mfdata</span></tt>. One wants to
evaluate <img class="math" src="../images/math/2a2e3c206d0e57c4f94f2b33119fce066ee89555.png" alt="\sum_{j} f_j (\int_\Omega \phi^i \psi^j)" style="vertical-align: -8px"/>. The instruction must be
seen as something that will be executed for each convex <tt class="docutils literal"><span class="pre">cv</span></tt> of the mesh. The
terms <tt class="docutils literal"><span class="pre">#1</span></tt> and <tt class="docutils literal"><span class="pre">#2</span></tt> refer to the first <cite>mesh_fem</cite> and the second one (i.e. <tt class="docutils literal"><span class="pre">mf</span></tt>
and <tt class="docutils literal"><span class="pre">mfdata</span></tt>).  The instruction <tt class="docutils literal"><span class="pre">Z=data(#2);</span></tt> means that for each convex, the
&#8220;tensor&#8221; <tt class="docutils literal"><span class="pre">Z</span></tt> will receive the values of the first data argument provided with
<tt class="docutils literal"><span class="pre">push_data</span></tt>, at indexes corresponding to the degrees of freedom attached to the
convex of the second (<tt class="docutils literal"><span class="pre">#2</span></tt>) <cite>mesh_fem</cite> (here, <tt class="docutils literal"><span class="pre">Z</span> <span class="pre">=</span>
<span class="pre">F[mfdata.ind_dof_of_element(cv)]</span></tt>).</p>
<p><tt class="docutils literal"><span class="pre">V(#1)+=...</span></tt> の部分は、次の式の結果が出力ベクトルに蓄積されることを意味します（ <tt class="docutils literal"><span class="pre">push_vec</span></tt> で提供されます）。ここでもまた、 <tt class="docutils literal"><span class="pre">#1</span></tt> は、最初の（ <tt class="docutils literal"><span class="pre">#1</span></tt> ） <cite>mesh_fem</cite> に関して、現在の凸の自由度に対応するインデックスに結果を書き込むことを意味します。</p>
<p>右側の <tt class="docutils literal"><span class="pre">comp(Base(#1).Base(#2))(:,j).Z(j)</span></tt> には2つの操作が含まれています。最初のものは、凸包のテンソルの計算です： <tt class="docutils literal"><span class="pre">comp(Base(#1).Base(#2))</span></tt> は2次元のテンソルとして評価されます <img class="math" src="../images/math/02425f28820e111e74f67b09c2ed97af3e200e91.png" alt="\int\phi^i \psi^j" style="vertical-align: -6px"/> をすべての自由度について計算します <tt class="docutils literal"><span class="pre">mf</span></tt> と現在の凸面に付けられた <tt class="docutils literal"><span class="pre">mfdata</span></tt> の <img class="math" src="../images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j" style="vertical-align: -4px"/> 。次の部分はリダクション演算で、 <tt class="docutils literal"><span class="pre">C(:,j).Z(j)</span></tt> ：それぞれの指数（ここでは <img class="math" src="../images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j" style="vertical-align: -4px"/> ）を合計します。結果は  <img class="math" src="../images/math/53d92e17e478e36bc7c7c3648425a50e73ad81d9.png" alt="\sum_j c_{i,j} z_j" style="vertical-align: -8px"/> となります。</p>
<p><tt class="docutils literal"><span class="pre">comp(Base(#1).Base(#2))</span></tt> の内部で使用される積分法は <tt class="docutils literal"><span class="pre">mim</span></tt> から取得されます。別の <cite>mesh_im</cite> オブジェクトから積分法を使用する必要がある場合は、<tt class="docutils literal"><span class="pre">comp</span></tt> の最初の引数として指定することができます、例えば、 <tt class="docutils literal"><span class="pre">comp(\%2,</span> <span class="pre">Base(#1).Grad(#2))</span></tt> は2番目の <cite>mesh_im</cite> オブジェクトを使用します（getfem++-2.0の新機能）。</p>
<p>他の例として、ベクトルLaplacianの剛性行列を構築します。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">getfem</span><span class="o">::</span><span class="n">generic_assembly</span> <span class="n">assem</span><span class="p">;</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_im</span><span class="p">(</span><span class="n">mim</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_mf</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_mf</span><span class="p">(</span><span class="n">mfdata</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_data</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_mat</span><span class="p">(</span><span class="n">SM</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;a=data$1(#2);&quot;</span>
          <span class="s">&quot;M$1(#1,#1)+=sym(comp(vGrad(#1).vGrad(#1).Base(#2))(:,j,k,:,j,k,p).a(p))&quot;</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">assembly</span><span class="p">();</span>
</pre></div>
</div>
<p>出力は、 <tt class="docutils literal"><span class="pre">assem.push_mat(SM)</span></tt> で挿入された疎行列に書き出されます。 <tt class="docutils literal"><span class="pre">M$1(#1,#1)</span></tt> の <tt class="docutils literal"><span class="pre">$1</span></tt> は最初の行列を &#8220;push&#8221; していることを示しています（オプションですが、2つの行列を構築するならば、2つ目はこのように参照する必要があります）。 <tt class="docutils literal"><span class="pre">sym</span></tt> 関数は、結果が対称であることを保証します（これが行われないと、いくつかの丸め誤差が対称性を取り消し、構築が少し遅くなることに留意してください）。次に、 <tt class="docutils literal"><span class="pre">comp</span></tt> 部分は7次テンソルを評価し、</p>
<div class="math">
<p><img src="../images/math/1a0f2ef86f64fc744959d5ec2748a297c7cfefce.png" alt="\int\partial_k\varphi^{i}_{j}\partial_n\varphi^l_m\psi^p,"/></p>
</div><p>ここで、 <img class="math" src="../images/math/677d3579b632acd0e5e6fd39e47b3d46a2ae6493.png" alt="\varphi^i_j" style="vertical-align: -8px"/> は <tt class="docutils literal"><span class="pre">mf</span></tt> の <img class="math" src="../images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> 次の基底関数の <img class="math" src="../images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j" style="vertical-align: -4px"/> 次成分で、 <img class="math" src="../images/math/703bc8604f06ff55b92c606c79b6621c03c61057.png" alt="\psi^p" style="vertical-align: -4px"/> は（スカラー） 2番目の <cite>mesh_fem</cite> の基底関数を構築したいので</p>
<div class="math">
<p><img src="../images/math/338c27bd3aa16e4bee7516b032088bf3a674b05b.png" alt="\int a(x).\nabla\phi^i.\nabla\phi^j,
\quad\text{with}\quad
a(x)=\sum_p a^p \psi^p(x),"/></p>
</div><p>換算は次のとおりです。</p>
<div class="math">
<p><img src="../images/math/95320980d6e4dba608192a367551a52cd852734a.png" alt="\sum_{j,k,p}\left(
\int \partial_k\varphi^{i}_{j} \partial_k\varphi^m_j \psi^p
\right)a^p"/></p>
</div><p><tt class="docutils literal"><span class="pre">comp</span></tt> 関数で <tt class="docutils literal"><span class="pre">Grad</span></tt> の代わりに <tt class="docutils literal"><span class="pre">vGrad</span></tt> が使われました。なぜなら、 Laplacian <em>ベクトル</em> をアセンブルしているためです。そのため、それぞれの <tt class="docutils literal"><span class="pre">vGrad</span></tt> 部分に3次元の（自由度番号、成分番号、および派生番号）があります。スカラLaplacianの場合、 <tt class="docutils literal"><span class="pre">comp(Grad(#1).Grad(#1).Base(#2))(:,k,:,k,p).a(p)</span></tt> を使うことができます。しかし、ベクトル形式はベクトルとスカラーの両方の場合に機能する利点があります。</p>
<p>最後の命令である <tt class="docutils literal"><span class="pre">assem.assembly()</span></tt> は各凸包の式を評価します。境界を越えて構築を呼び出すには、 <tt class="docutils literal"><span class="pre">assem.assembly(rg)</span></tt> を呼び出します。ここで <tt class="docutils literal"><span class="pre">rg</span></tt> は <tt class="docutils literal"><span class="pre">getfem::mesh_region</span></tt> オブジェクト。 <tt class="docutils literal"><span class="pre">rg</span></tt> も数値であるかもしれません。その場合メッシュ領域は <tt class="docutils literal"><span class="pre">mim.linked_mesh().region(rg)</span></tt> です。</p>
<p>3番目の例は、メッシュ境界上のスカラーまたはベクトルフィールドの <img class="math" src="../images/math/07c3de5211dc08b13546363f8b139700a16dd963.png" alt="L^2" style="vertical-align: 0px"/> ノルムを計算する方法を示します。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">assem</span><span class="p">.</span><span class="n">push_im</span><span class="p">(</span><span class="n">mim</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_mf</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_data</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">scalar_type</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">push_vec</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;u=data(#1);&quot;</span>
          <span class="s">&quot;V()+=u(i).u(j).comp(vBase(#1).vBase(#1))(i,k,j,k)&quot;</span><span class="p">);</span>
<span class="n">assem</span><span class="p">.</span><span class="n">assembly</span><span class="p">(</span><span class="n">boundary_number</span><span class="p">);</span>
</pre></div>
</div>
<p>これは読みやすいです。 <tt class="docutils literal"><span class="pre">assembly</span></tt> が返ってくるとき、 <tt class="docutils literal"><span class="pre">v[0]</span></tt> は次の通りです。</p>
<div class="math">
<p><img src="../images/math/f6f88ddcacd5030b5c9568bebbca9d617afb0bb0.png" alt="\sum_{i,j,k}\left(\int_{boundary} u_i \varphi^{i}_{k} u_j \varphi^j_k \right)"/></p>
</div><p>4番目と最後の例は、完全なHookeテンソルによる線形弾性問題の（準最適な）構築を示しています。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">assem</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;h=data$1(qdim(#1),qdim(#1),qdim(#1),qdim(#1),#2);&quot;</span>
          <span class="s">&quot;t=comp(vGrad(#1).vGrad(#1).Base(#2));&quot;</span>
          <span class="s">&quot;e=(t{:,2,3,:,5,6,:}+t{:,3,2,:,5,6,:}+t{:,2,3,:,6,5,:}+t{:,3,2,:,6,5,:})/4;&quot;</span>
          <span class="s">&quot;M(#1,#1)+= sym(e(:,j,k,:,m,n,p).h(j,k,m,n,p))&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>元の方程式は次のとおりです。</p>
<div class="math">
<p><img src="../images/math/aa5a5f06f7b23d0b9c4599a5068f83dcf47fcfdf.png" alt="\int\varepsilon(\varphi^i):\sigma(\phi^j),
\quad\text{with}\quad
\sigma(u)_{ij}=\sum_{kl} h_{ijkl}(x) \varepsilon_{kl}(u)"/></p>
</div><p><img class="math" src="../images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h" style="vertical-align: 0px"/> はHookeテンソル、そして <img class="math" src="../images/math/9e89270aa29dd200d6388cdaf4b31cb721b62ba8.png" alt=":" style="vertical-align: 0px"/> は行列間のスカラ積を意味します。定数ではないと仮定しているので、第2の <cite>mesh_fem</cite>: <img class="math" src="../images/math/00458f29e5e2fc5e5fdcd26d61cef27920ff29db.png" alt="h_{ijkl}(x)=\sum_p h_{ijkl}^p \psi^p" style="vertical-align: -8px"/> に <img class="math" src="../images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h" style="vertical-align: 0px"/> が与えられます。したがって、最初の行は、最初のデータが実際に5次元のテンソルであることを宣言します。最初の4番目のものはすべて最初の <cite>mesh_fem</cite> のターゲット次元に等しく、最後のものは次の第2の <cite>mesh_fem</cite> の自由度数に等しくなり、 <tt class="docutils literal"><span class="pre">comp</span></tt> 部分はベクトルLaplacianの場合と同じ7次テンソルを計算します。このテンソルから、順列を使って <img class="math" src="../images/math/bb2f13727922cacb774b1a3255eaefe68179ff98.png" alt="\varepsilon(\varphi^i)_{jk}\varepsilon(\phi^l)_{mn}\psi^p" style="vertical-align: -6px"/> を評価し最後に表現はHookeテンソルに換算されます。</p>
<div class="section" id="available-operations-inside-the-comp-command">
<h2><tt class="docutils literal"><span class="pre">comp</span></tt> コマンドの中で利用可能な操作<a class="headerlink" href="#available-operations-inside-the-comp-command" title="このヘッドラインへのパーマリンク">¶</a></h2>
<ul class="simple">
<li><p class="first"><tt class="docutils literal"><span class="pre">Base(#i)</span></tt>: <em>i</em> 次 <cite>mesh_fem</cite> の基底関数の値を評価します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Grad(#i)</span></tt>:  <em>i</em> 次 <cite>mesh_fem</cite> の基底関数の勾配の値を評価します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Hess(#i)</span></tt>: <em>i</em> 次 <cite>mesh_fem</cite> の基底関数のHessianの値を評価します。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Normal()</span></tt>: 単位法線を評価します（体積積分には使用しないでください）。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">NonLin$x(#mf1,...</span> <span class="pre">#mfn)</span></tt>： <tt class="docutils literal"><span class="pre">push_nonlinear_term(pnonlinear_elem_term)</span></tt> で挿入された、リストされた <cite>mesh_fem</cite> オブジェクトを使用した <em>x</em> 次非線形項の計算。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">GradGT()</span></tt>、 <tt class="docutils literal"><span class="pre">GradGTInv()</span></tt>：現在の凸包の幾何学的変換の勾配（およびその逆数）を評価します。</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last"><tt class="docutils literal"><span class="pre">comp</span></tt> コマンドの中の任意のデータオブジェクトを参照し、 <tt class="docutils literal"><span class="pre">comp()</span></tt> の中で縮小を実行することができます。この機能は非線形項の構築を高速化するために有用です（ファイル <tt class="file docutils literal"><span class="pre">getfem/getfem_nonlinear_elasticity.h</span></tt> の使用例を参照）。</p>
</div>
</div>
<div class="section" id="others-operations">
<h2>他の操作<a class="headerlink" href="#others-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スライスは縮小演算と混在することがあります。 <tt class="docutils literal"><span class="pre">t(:,4,i,i)</span></tt> は第2次元のインデックス4でスライスをとり、次元3と4の対角を縮小します。 <em>スライスのインデックス番号は1ではなく0で始まることに留意してください!!</em></p>
<p><tt class="docutils literal"><span class="pre">mdim(#2)</span></tt> は第2の <cite>mesh_fem</cite> に関連するメッシュ次元として評価され、 <tt class="docutils literal"><span class="pre">qdim(#2)</span></tt> は <cite>mesh_fem</cite> の対象次元です。</p>
<p>テンソルの対角は <tt class="docutils literal"><span class="pre">t{:,:,3,3}</span></tt> で得ることができます。(厳密には <tt class="docutils literal"><span class="pre">t{1,2,3,3}</span></tt> と同等です: コロンは読みやすさを向上させるためだけです）。これは、並べ替え操作と同じ演算子です。 <tt class="docutils literal"><span class="pre">t{:,:,1,1}</span></tt> や <tt class="docutils literal"><span class="pre">t{:,:,4,4}</span></tt> は有効な操作ではないことに注意してください。</p>
<p><tt class="docutils literal"><span class="pre">print</span></tt> コマンドは、テンソルを見るために使うことができます： <tt class="docutils literal"><span class="pre">&quot;print</span> <span class="pre">comp(Base(#1));&quot;</span></tt> は各凸包の基底関数の積分を出力します。</p>
<p>If there is more than one data array, output array or output sparse
matrix, one can use <tt class="docutils literal"><span class="pre">data$2</span></tt>, <tt class="docutils literal"><span class="pre">data$3</span></tt>, <tt class="docutils literal"><span class="pre">V$2</span></tt>, <tt class="docutils literal"><span class="pre">M$2</span></tt>,...</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <p class="logo"><a href="../index.html">
    <img class="logo" src="../static/logo_getfem_small.png" alt="Logo"/>
  </a></p>
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">任意の項を計算する - 低水準の汎用的な構築手順</a><ul>
<li><a class="reference internal" href="#available-operations-inside-the-comp-command"><tt class="docutils literal"><span class="pre">comp</span></tt> コマンドの中で利用可能な操作</a></li>
<li><a class="reference internal" href="#others-operations">他の操作</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="gasm_high.html"
                        title="前の章へ">任意の項を計算する - 高水準の汎用的な構築手順 - 弱形式言語</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="asm.html"
                        title="次の章へ">いくつかの標準構築手順（低水準汎用構築）</a></p>            <h3>Download</h3>
            <p><a href="../download.html">Download GetFEM++ </a></p>
	    <h3>Main documentations</h3>
	    <ul>
              
	      <li><a href="index.html">GetFEM++ User documentation</a></li>
              <li><a href="../python/index.html">Python Interface</a></li>
	      <li><a href="../matlab/index.html">Matlab Interface</a></li>
	      <li><a href="../scilab/index.html">Scilab Interface</a></li>
	      <li><a href="../gmm/index.html"> Gmm++</a></li>
	      <li><a href="../project/index.html"> GetFEM++ project</a></li>
            </ul>

            <h3>Other resources</h3>
            <ul>
              <li><a href="../screenshots/shots.html">Screenshots</a></li>
              <li><a href="../links.html">Related links</a></li>
	      <li><a href="https://savannah.nongnu.org/projects/getfem">Hosted by Savannah </a></li>
              
              
            </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="asm.html" title="いくつかの標準構築手順（低水準汎用構築）"
             >次へ</a> |</li>
        <li class="right" >
          <a href="gasm_high.html" title="任意の項を計算する - 高水準の汎用的な構築手順 - 弱形式言語"
             >前へ</a> |</li>
        <li><a href="https://savannah.nongnu.org/projects/getfem" <img src="../static/icon.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li></a>
        <li><a href="../index.html">GetFEM++</a> &raquo;</li>

          <li><a href="index.html" >ユーザドキュメント</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2004-2017 GetFEM++ project.
    </div>
  </body>
</html>